[
  {
    "function_name": "glp_eval_tab_row",
    "function_name_in_strip": "glp_eval_tab_row",
    "comment": "NAME- compute row of the simplex tableauSYNOPSISint(glp_problp, int k, int ind[], double val[]);DESCRIPTIONThe routine computes a row of the current simplextableau for the basic variable, which is specified by the number k:if 1 <k <m, x[k] is k-th auxiliary variable; if m+1 <k <m+n,x[k] is (k-m)-th structural variable, where m is number of rows, andn is number of columns",
    "function_body": [
      "PUSH <SPECIAL>",
      "LDR R11, [R0+<POSITIVE>]",
      "SUB SP, SP, <POSITIVE>",
      "STR R3, [SP+<POSITIVE>]",
      "LDR R3, [R0+<POSITIVE>]",
      "CMP R11, <ZERO>",
      "MOV R9, R0",
      "MOV R5, R1",
      "STR R2, [SP+<POSITIVE>]",
      "STR R3, [SP+<POSITIVE>]",
      "B <NEAR>",
      "LDR R3, [R0+<POSITIVE>]",
      "CMP R3, <ZERO>",
      "B <NEAR>",
      "LDR R3, [SP+<POSITIVE>]",
      "CMP R5, <ZERO>",
      "ADD R3, R11, R3",
      "STR R3, [SP+<POSITIVE>]",
      "B <NEAR>",
      "CMP R5, R3",
      "B <NEAR>",
      "CMP R11, R5",
      "B <NEAR>",
      "MOV R1, R5",
      "MOV R0, R9",
      "BL <ECALL> j_glp_get_row_bind",
      "MOV R4, R0",
      "CMP R4, <ZERO>",
      "B <NEAR>",
      "MOV R3, <POSITIVE>",
      "MOV R3, <ZERO>",
      "CMP R4, R11",
      "MOV R3, <ZERO>",
      "AND R3, R3, <POSITIVE>",
      "CMP R3, <ZERO>",
      "B <NEAR>",
      "ADD R5, R11, <POSITIVE>",
      "MOV R1, <POSITIVE>",
      "MOV R0, R5",
      "BL <ECALL> j_glp_alloc",
      "MOV R1, <POSITIVE>",
      "STR R0, [SP+<POSITIVE>]",
      "MOV R0, R5",
      "BL <ECALL> j_glp_alloc",
      "MOV R1, <POSITIVE>",
      "STR R0, [SP+<POSITIVE>]",
      "MOV R0, R5",
      "BL <ECALL> j_glp_alloc",
      "STR R0, [SP+<POSITIVE>]",
      "LDR R3, [SP+<POSITIVE>]",
      "MOV R2, <SPECIAL>",
      "MOV R1, <ZERO>",
      "ADD R0, R3, <POSITIVE>",
      "BL <ECALL> memset",
      "MOV R2, <ZERO>",
      "LDR R1, [SP+<POSITIVE>]",
      "LDR R3, <MEM> =0x3FF00000",
      "ADD R4, R1, <SPECIAL>",
      "STM R4, <SPECIAL>",
      "MOV R0, R9",
      "BL <ECALL> j_glp_btran",
      "LDR R3, [SP+<POSITIVE>]",
      "CMP R3, <ZERO>",
      "MOV R8, <ZERO>",
      "B <NEAR>",
      "CMP R11, <ZERO>",
      "MOV R8, <ZERO>",
      "MOV R4, <POSITIVE>",
      "B <NEAR>",
      "STR R11, [SP+<POSITIVE>]",
      "LDR R3, [SP+<POSITIVE>]",
      "MOV R0, R9",
      "SUB R5, R4, R3",
      "MOV R1, R5",
      "BL <ECALL> j_glp_get_col_stat",
      "CMP R0, <POSITIVE>",
      "B <NEAR>",
      "MOV R1, R5",
      "LDR R10, [SP+<POSITIVE>]",
      "LDR R5, [SP+<POSITIVE>]",
      "MOV R3, R10",
      "MOV R2, R5",
      "MOV R0, R9",
      "BL <ECALL> j_glp_get_mat_col",
      "CMP R0, <ZERO>",
      "B <NEAR>",
      "MOV R6, <ZERO>",
      "MOV R7, <ZERO>",
      "STR R9, [SP+<POSITIVE>]",
      "MOV R9, R8",
      "MOV R8, R4",
      "LDR R4, [SP+<POSITIVE>]",
      "ADD R11, R5, <SPECIAL>",
      "ADD R10, R10, <POSITIVE>",
      "LDR R3, [R5+<POSITIVE>]",
      "LDM R10!, <SPECIAL>",
      "ADD R3, R4, <SPECIAL>",
      "LDM R3, <SPECIAL>",
      "BL <ICALL>",
      "MOV R2, R0",
      "MOV R3, R1",
      "MOV R0, R6",
      "MOV R1, R7",
      "BL <ICALL>",
      "CMP R11, R5",
      "MOV R6, R0",
      "MOV R7, R1",
      "B <NEAR>",
      "MOV R2, <ZERO>",
      "MOV R3, <ZERO>",
      "BL <ICALL>",
      "CMP R0, <ZERO>",
      "MOV R4, R8",
      "MOV R8, R9",
      "LDR R9, [SP+<POSITIVE>]",
      "B <NEAR>",
      "LDR R3, [SP+<POSITIVE>]",
      "ADD R8, R8, <POSITIVE>",
      "LDR R2, [SP+<POSITIVE>]",
      "ADD R3, R3, <SPECIAL>",
      "STR R4, [R2,R8,LSL#2]",
      "STM R3, <SPECIAL>",
      "LDR R3, [SP+<POSITIVE>]",
      "ADD R4, R4, <POSITIVE>",
      "CMP R3, R4",
      "B <NEAR>",
      "LDR R3, [SP+<POSITIVE>]",
      "CMP R3, R8",
      "B <NEAR>",
      "LDR R1, <MEM> =(aDraftGlpapi12C - 0x55C50)",
      "LDR R0, <MEM> =(a0LenLenN+0xC - 0x55C54)",
      "LDR R2, <MEM> =0x355",
      "ADD R1, PC, R1",
      "ADD R0, PC, R0",
      "BL <ECALL> j_glp_assert_",
      "LDR R0, [SP+<POSITIVE>]",
      "BL <ECALL> j_glp_free",
      "LDR R0, [SP+<POSITIVE>]",
      "BL <ECALL> j_glp_free",
      "LDR R0, [SP+<POSITIVE>]",
      "BL <ECALL> j_glp_free",
      "MOV R0, R8",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>",
      "LDR R0, <MEM> =(aDraftGlpapi12C - 0x55C88)",
      "LDR R1, <MEM> =0x32E",
      "ADD R0, PC, R0",
      "BL <ECALL> j_glp_error_",
      "MOV R3, R0",
      "LDR R0, <MEM> =(aGlpEvalTabRowK - 0x55C9C)",
      "MOV R1, R5",
      "ADD R0, PC, R0",
      "BLX <ICALL>",
      "CMP R11, R5",
      "B <NEAR>",
      "SUB R1, R5, R11",
      "MOV R0, R9",
      "BL <ECALL> j_glp_get_col_bind",
      "MOV R4, R0",
      "CMP R4, <ZERO>",
      "B <NEAR>",
      "LDR R0, <MEM> =(aDraftGlpapi12C - 0x55CCC)",
      "LDR R1, <MEM> =0x336",
      "ADD R0, PC, R0",
      "BL <ECALL> j_glp_error_",
      "MOV R3, R0",
      "LDR R0, <MEM> =(aGlpEvalTabRowK_0 - 0x55CE0)",
      "MOV R1, R5",
      "ADD R0, PC, R0",
      "BLX <ICALL>",
      "LDR R1, <MEM> =(aDraftGlpapi12C - 0x55CF8)",
      "LDR R0, <MEM> =(a1IIM - 0x55CFC)",
      "LDR R2, <MEM> =0x337",
      "ADD R5, R11, <POSITIVE>",
      "ADD R1, PC, R1",
      "ADD R0, PC, R0",
      "BL <ECALL> j_glp_assert_",
      "MOV R1, <POSITIVE>",
      "MOV R0, R5",
      "BL <ECALL> j_glp_alloc",
      "MOV R1, <POSITIVE>",
      "STR R0, [SP+<POSITIVE>]",
      "MOV R0, R5",
      "BL <ECALL> j_glp_alloc",
      "MOV R1, <POSITIVE>",
      "STR R0, [SP+<POSITIVE>]",
      "MOV R0, R5",
      "BL <ECALL> j_glp_alloc",
      "CMP R11, <ZERO>",
      "STR R0, [SP+<POSITIVE>]",
      "B <NEAR>",
      "B <NEAR>",
      "CMP R11, R3",
      "MOV R10, R11",
      "MOV R8, <ZERO>",
      "MOV R4, <POSITIVE>",
      "MOV R10, R3",
      "LDR R3, [SP+<POSITIVE>]",
      "ADD R5, R3, <POSITIVE>",
      "MOV R1, R4",
      "MOV R0, R9",
      "BL <ECALL> j_glp_get_row_stat",
      "CMP R0, <POSITIVE>",
      "B <NEAR>",
      "LDR R6, [R5+<POSITIVE>]",
      "LDR R7, [R5+<ZERO>]",
      "MOV R1, R6",
      "MOV R0, R7",
      "MOV R2, <ZERO>",
      "MOV R3, <ZERO>",
      "BL <ICALL>",
      "CMP R0, <ZERO>",
      "ADD R6, R6, <NEGATIVE>",
      "B <NEAR>",
      "MOV R2, R7",
      "MOV R3, R6",
      "LDR R1, [SP+<POSITIVE>]",
      "ADD R8, R8, <POSITIVE>",
      "LDR R0, [SP+<POSITIVE>]",
      "ADD R1, R1, <SPECIAL>",
      "STR R4, [R0,R8,LSL#2]",
      "STM R1, <SPECIAL>",
      "ADD R4, R4, <POSITIVE>",
      "CMP R4, R10",
      "ADD R5, R5, <POSITIVE>",
      "B <NEAR>",
      "LDR R3, [SP+<POSITIVE>]",
      "CMP R4, R3",
      "B <NEAR>",
      "B <NEAR>",
      "LDR R0, <MEM> =(aDraftGlpapi12C - 0x55DE0)",
      "LDR R1, <MEM> =0x32B",
      "ADD R0, PC, R0",
      "BL <ECALL> j_glp_error_",
      "MOV R3, R0",
      "LDR R0, <MEM> =(aGlpEvalTabRowB - 0x55DF0)",
      "ADD R0, PC, R0",
      "BLX <ICALL>",
      "B <NEAR>"
    ],
    "pseudo_code": "int __fastcall glp_eval_tab_row(_DWORD *a1, int a2, int a3, int a4)\n{\n  int v4; // r10\n  int v5; // r11\n  int row_bind; // r4\n  bool v9; // cc\n  char v10; // r3\n  int v11; // r3\n  _DWORD *v12; // r4\n  int v13; // r8\n  int v14; // r4\n  int v15; // r5\n  int mat_col; // r0\n  __int64 v17; // r6\n  int v18; // r11\n  int *v19; // r10\n  int v20; // t1\n  int v21; // r0\n  int v22; // r1\n  __int64 v23; // r0\n  void (*v25)(const char *, ...); // r0\n  void (*v26)(const char *, ...); // r0\n  _DWORD *v27; // r5\n  int v28; // r7\n  unsigned int v29; // r6\n  _DWORD *v30; // r1\n  void (__fastcall *v31)(const char *); // r0\n  int v32; // [sp+4h] [bp-4Ch]\n  int v33; // [sp+8h] [bp-48h]\n  int v34; // [sp+Ch] [bp-44h]\n  int v37; // [sp+1Ch] [bp-34h]\n  int v38; // [sp+20h] [bp-30h]\n  int v39; // [sp+24h] [bp-2Ch]\n\n  v5 = a1[10];\n  v39 = a1[11];\n  if ( v5 && !a1[17] )\n  {\n    v31 = (void (__fastcall *)(const char *))j_glp_error_(\"draft/glpapi12.c\", 811);\n    v31(\"glp_eval_tab_row: basis factorization does not exist\\n\");\n  }\n  v32 = v5 + v39;\n  if ( a2 <= 0 || a2 > v5 + v39 )\n  {\n    v25 = (void (*)(const char *, ...))j_glp_error_(\"draft/glpapi12.c\", 814);\n    v25(\"glp_eval_tab_row: k = %d; variable number out of range\", a2);\n    if ( v5 >= a2 )\n    {\nLABEL_7:\n      row_bind = j_glp_get_row_bind(a1, a2);\n      v9 = row_bind <= 0;\n      if ( row_bind )\n        goto LABEL_8;\nLABEL_35:\n      v26 = (void (*)(const char *, ...))j_glp_error_(\"draft/glpapi12.c\", 822);\n      v26(\"glp_eval_tab_row: k = %d; variable must be basic\", a2);\n      goto LABEL_36;\n    }\n  }\n  else if ( v5 >= a2 )\n  {\n    goto LABEL_7;\n  }\n  row_bind = j_glp_get_col_bind(a1, a2 - v5);\n  v9 = row_bind <= 0;\n  if ( !row_bind )\n    goto LABEL_35;\nLABEL_8:\n  v10 = !v9;\n  if ( row_bind <= v5 )\n    v11 = v10 & 1;\n  else\n    v11 = 0;\n  if ( v11 )\n  {\n    v34 = j_glp_alloc(v5 + 1, 8);\n    v37 = j_glp_alloc(v5 + 1, 4);\n    v38 = j_glp_alloc(v5 + 1, 8);\nLABEL_16:\n    memset((void *)(v34 + 8), 0, 8 * v5);\n    goto LABEL_17;\n  }\nLABEL_36:\n  j_glp_assert_(\"1 <= i && i <= m\", \"draft/glpapi12.c\", 823);\n  v34 = j_glp_alloc(v5 + 1, 8);\n  v37 = j_glp_alloc(v5 + 1, 4);\n  v38 = j_glp_alloc(v5 + 1, 8);\n  if ( v5 > 0 )\n    goto LABEL_16;\nLABEL_17:\n  v12 = (_DWORD *)(v34 + 8 * row_bind);\n  *v12 = 0;\n  v12[1] = 1072693248;\n  j_glp_btran(__SPAIR64__(v34, (unsigned int)a1));\n  if ( v32 <= 0 )\n  {\n    v13 = 0;\n    goto LABEL_30;\n  }\n  if ( v5 <= 0 )\n  {\n    v13 = 0;\n    v14 = 1;\nLABEL_22:\n    v33 = v5;\n    do\n    {\n      if ( j_glp_get_col_stat(a1, v14 - v33) != 1 )\n      {\n        v15 = v37;\n        mat_col = j_glp_get_mat_col(a1, v14 - v33, v37, v38);\n        if ( mat_col > 0 )\n        {\n          v17 = 0LL;\n          v18 = v37 + 4 * mat_col;\n          v19 = (int *)(v38 + 8);\n          do\n          {\n            v20 = *(_DWORD *)(v15 + 4);\n            v15 += 4;\n            v21 = *v19;\n            v22 = v19[1];\n            v19 += 2;\n            sub_EA2A0(v21, v22, *(_DWORD *)(v34 + 8 * v20), *(_DWORD *)(v34 + 8 * v20 + 4));\n            v23 = sub_E9EEC(v17, HIDWORD(v17));\n            v17 = v23;\n          }\n          while ( v18 != v15 );\n          if ( !sub_EA7D8(v23, HIDWORD(v23), 0, 0) )\n          {\n            ++v13;\n            *(_DWORD *)(a3 + 4 * v13) = v14;\n            *(_QWORD *)(a4 + 8 * v13) = v17;\n          }\n        }\n      }\n      ++v14;\n    }\n    while ( v32 >= v14 );\n    goto LABEL_30;\n  }\n  if ( v5 < v32 )\n    v4 = v5;\n  v13 = 0;\n  v14 = 1;\n  if ( v5 >= v32 )\n    v4 = v5 + v39;\n  v27 = (_DWORD *)(v34 + 8);\n  do\n  {\n    if ( j_glp_get_row_stat(a1, v14) != 1 )\n    {\n      v28 = *v27;\n      v29 = v27[1] + 0x80000000;\n      if ( !sub_EA7D8(*v27, v27[1], 0, 0) )\n      {\n        ++v13;\n        v30 = (_DWORD *)(a4 + 8 * v13);\n        *(_DWORD *)(a3 + 4 * v13) = v14;\n        *v30 = v28;\n        v30[1] = v29;\n      }\n    }\n    ++v14;\n    v27 += 2;\n  }\n  while ( v14 <= v4 );\n  if ( v14 <= v32 )\n    goto LABEL_22;\nLABEL_30:\n  if ( v39 < v13 )\n    j_glp_assert_(\"len <= n\", \"draft/glpapi12.c\", 853);\n  j_glp_free(v34);\n  j_glp_free(v37);\n  j_glp_free(v38);\n  return v13;\n}\n",
    "cfg": {
      "nodes": [
        "LDR_R0_<MEM>",
        "ADD_SP_SP_<POSITIVE>",
        "MOV_R3_R6",
        "LDR_R3_<MEM>",
        "ADD_R6_R6_<NEGATIVE>",
        "MOV_R0_R6",
        "LDR_R1_<MEM>",
        "STR_R9_[SP*None+<POSITIVE>]",
        "ADD_R1_R1_<SPECIAL>",
        "STR_R2_[SP*None+<POSITIVE>]",
        "MOV_R6_R0",
        "ADD_R1_PC_R1",
        "ADD_R8_R8_<POSITIVE>",
        "STR_R0_[SP*None+<POSITIVE>]",
        "ADD_R5_R11_<POSITIVE>",
        "LDR_R4_[SP*None+<POSITIVE>]",
        "B_<NEAR>",
        "MOV_R9_R8",
        "ADD_R0_R3_<POSITIVE>",
        "CMP_R4_R10",
        "CMP_R3_R8",
        "MOV_R8_R4",
        "LDR_R5_[SP*None+<POSITIVE>]",
        "ADD_R0_PC_R0",
        "MOV_R1_R4",
        "ADD_R3_R3_<SPECIAL>",
        "MOV_R3_R0",
        "CMP_R4_R11",
        "MOV_R2_<ZERO>",
        "LDR_R7_[R5*None+<ZERO>]",
        "LDR_R10_[SP*None+<POSITIVE>]",
        "CMP_R4_R3",
        "BL_<ICALL>",
        "MOV_R3_R1",
        "STM_R1_<SPECIAL>",
        "MOV_R1_R5",
        "CMP_R5_R3",
        "MOV_R4_R0",
        "LDR_R2_[SP*None+<POSITIVE>]",
        "CMP_R5_<ZERO>",
        "MOV_R0_R8",
        "LDR_R1_[SP*None+<POSITIVE>]",
        "BLX_<ICALL>",
        "STR_R4_[R0]",
        "ADD_R3_R4_<SPECIAL>",
        "LDR_R11_[R0*None+<POSITIVE>]",
        "ADD_R4_R1_<SPECIAL>",
        "MOV_R4_R8",
        "MOV_R9_R0",
        "ADD_R3_R11_R3",
        "CMP_R11_R5",
        "CMP_R11_R3",
        "MOV_R2_R0",
        "STM_R4_<SPECIAL>",
        "MOV_R8_R9",
        "LDR_R3_[R5*None+<POSITIVE>]",
        "MOV_R7_R1",
        "MOV_R0_R9",
        "MOV_R6_<ZERO>",
        "STR_R4_[R2]",
        "MOV_R1_R6",
        "STM_R3_<SPECIAL>",
        "CMP_R0_<POSITIVE>",
        "CMP_R0_<ZERO>",
        "LDM_R10!_<SPECIAL>",
        "MOV_R3_R10",
        "STR_R3_[SP*None+<POSITIVE>]",
        "MOV_R3_<POSITIVE>",
        "MOV_R10_R3",
        "MOV_R7_<ZERO>",
        "LDR_R3_[R0*None+<POSITIVE>]",
        "SUB_R5_R4_R3",
        "MOV_R5_R1",
        "LDR_R2_<MEM>",
        "ADD_R10_R10_<POSITIVE>",
        "MOV_R0_R5",
        "PUSH_<SPECIAL>",
        "ADD_R11_R5_<SPECIAL>",
        "MOV_R1_<ZERO>",
        "MOV_R2_R5",
        "MOV_R1_R7",
        "MOV_R1_<POSITIVE>",
        "ADD_R5_R5_<POSITIVE>",
        "MOV_R10_R11",
        "MOV_R8_<ZERO>",
        "MOV_R2_<SPECIAL>",
        "CMP_R4_<ZERO>",
        "LDR_R0_[SP*None+<POSITIVE>]",
        "CMP_R3_<ZERO>",
        "MOV_R3_<ZERO>",
        "CMP_R11_<ZERO>",
        "LDR_R3_[SP*None+<POSITIVE>]",
        "CMP_R3_R4",
        "MOV_R4_<POSITIVE>",
        "POP_<SPECIAL>",
        "ADD_R4_R4_<POSITIVE>",
        "SUB_R1_R5_R11",
        "LDM_R3_<SPECIAL>",
        "MOV_R2_R7",
        "AND_R3_R3_<POSITIVE>",
        "STR_R11_[SP*None+<POSITIVE>]",
        "BL_<ECALL>",
        "MOV_R0_R7",
        "ADD_R5_R3_<POSITIVE>",
        "LDR_R9_[SP*None+<POSITIVE>]",
        "LDR_R6_[R5*None+<POSITIVE>]",
        "SUB_SP_SP_<POSITIVE>"
      ],
      "edges": "[('LDR_R0_<MEM>', 'LDR_R2_<MEM>'), ('LDR_R0_<MEM>', 'LDR_R1_<MEM>'), ('LDR_R0_<MEM>', 'MOV_R1_R5'), ('LDR_R0_<MEM>', 'ADD_R0_PC_R0'), ('ADD_SP_SP_<POSITIVE>', 'POP_<SPECIAL>'), ('MOV_R3_R6', 'LDR_R1_[SP*None+<POSITIVE>]'), ('LDR_R3_<MEM>', 'ADD_R4_R1_<SPECIAL>'), ('ADD_R6_R6_<NEGATIVE>', 'B_<NEAR>'), ('MOV_R0_R6', 'MOV_R1_R7'), ('LDR_R1_<MEM>', 'ADD_R0_PC_R0'), ('LDR_R1_<MEM>', 'LDR_R0_<MEM>'), ('STR_R9_[SP*None+<POSITIVE>]', 'MOV_R9_R8'), ('ADD_R1_R1_<SPECIAL>', 'STR_R4_[R0]'), ('STR_R2_[SP*None+<POSITIVE>]', 'STR_R3_[SP*None+<POSITIVE>]'), ('MOV_R6_R0', 'MOV_R7_R1'), ('ADD_R1_PC_R1', 'ADD_R0_PC_R0'), ('ADD_R8_R8_<POSITIVE>', 'LDR_R0_[SP*None+<POSITIVE>]'), ('ADD_R8_R8_<POSITIVE>', 'LDR_R2_[SP*None+<POSITIVE>]'), ('STR_R0_[SP*None+<POSITIVE>]', 'B_<NEAR>'), ('STR_R0_[SP*None+<POSITIVE>]', 'MOV_R0_R5'), ('STR_R0_[SP*None+<POSITIVE>]', 'LDR_R3_[SP*None+<POSITIVE>]'), ('ADD_R5_R11_<POSITIVE>', 'ADD_R1_PC_R1'), ('ADD_R5_R11_<POSITIVE>', 'MOV_R1_<POSITIVE>'), ('LDR_R4_[SP*None+<POSITIVE>]', 'ADD_R11_R5_<SPECIAL>'), ('B_<NEAR>', 'MOV_R2_R7'), ('B_<NEAR>', 'MOV_R2_<ZERO>'), ('B_<NEAR>', 'LDR_R6_[R5*None+<POSITIVE>]'), ('B_<NEAR>', 'B_<NEAR>'), ('B_<NEAR>', 'ADD_R4_R4_<POSITIVE>'), ('B_<NEAR>', 'MOV_R3_<POSITIVE>'), ('B_<NEAR>', 'LDR_R1_<MEM>'), ('B_<NEAR>', 'CMP_R5_R3'), ('B_<NEAR>', 'LDR_R3_[R0*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R3_[R5*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R0_<MEM>'), ('B_<NEAR>', 'MOV_R1_R5'), ('B_<NEAR>', 'ADD_R5_R11_<POSITIVE>'), ('B_<NEAR>', 'CMP_R11_R5'), ('B_<NEAR>', 'SUB_R1_R5_R11'), ('B_<NEAR>', 'CMP_R11_<ZERO>'), ('B_<NEAR>', 'STR_R11_[SP*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R0_[SP*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R3_[SP*None+<POSITIVE>]'), ('B_<NEAR>', 'MOV_R6_<ZERO>'), ('B_<NEAR>', 'CMP_R11_R3'), ('B_<NEAR>', 'MOV_R1_R4'), ('MOV_R9_R8', 'MOV_R8_R4'), ('ADD_R0_R3_<POSITIVE>', 'BL_<ECALL>'), ('CMP_R4_R10', 'ADD_R5_R5_<POSITIVE>'), ('CMP_R3_R8', 'B_<NEAR>'), ('MOV_R8_R4', 'LDR_R4_[SP*None+<POSITIVE>]'), ('LDR_R5_[SP*None+<POSITIVE>]', 'MOV_R3_R10'), ('ADD_R0_PC_R0', 'BLX_<ICALL>'), ('ADD_R0_PC_R0', 'BL_<ECALL>'), ('MOV_R1_R4', 'MOV_R0_R9'), ('ADD_R3_R3_<SPECIAL>', 'STR_R4_[R2]'), ('MOV_R3_R0', 'LDR_R0_<MEM>'), ('CMP_R4_R11', 'MOV_R3_<ZERO>'), ('MOV_R2_<ZERO>', 'MOV_R3_<ZERO>'), ('MOV_R2_<ZERO>', 'LDR_R1_[SP*None+<POSITIVE>]'), ('LDR_R7_[R5*None+<ZERO>]', 'MOV_R1_R6'), ('LDR_R10_[SP*None+<POSITIVE>]', 'LDR_R5_[SP*None+<POSITIVE>]'), ('CMP_R4_R3', 'B_<NEAR>'), ('BL_<ICALL>', 'MOV_R2_R0'), ('BL_<ICALL>', 'CMP_R11_R5'), ('BL_<ICALL>', 'CMP_R0_<ZERO>'), ('MOV_R3_R1', 'MOV_R0_R6'), ('STM_R1_<SPECIAL>', 'ADD_R4_R4_<POSITIVE>'), ('MOV_R1_R5', 'ADD_R0_PC_R0'), ('MOV_R1_R5', 'LDR_R10_[SP*None+<POSITIVE>]'), ('MOV_R1_R5', 'MOV_R0_R9'), ('MOV_R1_R5', 'BL_<ECALL>'), ('CMP_R5_R3', 'B_<NEAR>'), ('MOV_R4_R0', 'CMP_R4_<ZERO>'), ('LDR_R2_[SP*None+<POSITIVE>]', 'ADD_R3_R3_<SPECIAL>'), ('CMP_R5_<ZERO>', 'ADD_R3_R11_R3'), ('MOV_R0_R8', 'ADD_SP_SP_<POSITIVE>'), ('LDR_R1_[SP*None+<POSITIVE>]', 'LDR_R3_<MEM>'), ('LDR_R1_[SP*None+<POSITIVE>]', 'ADD_R8_R8_<POSITIVE>'), ('BLX_<ICALL>', 'B_<NEAR>'), ('BLX_<ICALL>', 'LDR_R1_<MEM>'), ('BLX_<ICALL>', 'CMP_R11_R5'), ('STR_R4_[R0]', 'STM_R1_<SPECIAL>'), ('ADD_R3_R4_<SPECIAL>', 'LDM_R3_<SPECIAL>'), ('LDR_R11_[R0*None+<POSITIVE>]', 'SUB_SP_SP_<POSITIVE>'), ('ADD_R4_R1_<SPECIAL>', 'STM_R4_<SPECIAL>'), ('MOV_R4_R8', 'MOV_R8_R9'), ('MOV_R9_R0', 'MOV_R5_R1'), ('ADD_R3_R11_R3', 'STR_R3_[SP*None+<POSITIVE>]'), ('CMP_R11_R5', 'MOV_R6_R0'), ('CMP_R11_R5', 'B_<NEAR>'), ('CMP_R11_R3', 'MOV_R10_R11'), ('MOV_R2_R0', 'MOV_R3_R1'), ('STM_R4_<SPECIAL>', 'MOV_R0_R9'), ('MOV_R8_R9', 'LDR_R9_[SP*None+<POSITIVE>]'), ('LDR_R3_[R5*None+<POSITIVE>]', 'LDM_R10!_<SPECIAL>'), ('MOV_R7_R1', 'B_<NEAR>'), ('MOV_R0_R9', 'SUB_R5_R4_R3'), ('MOV_R0_R9', 'BL_<ECALL>'), ('MOV_R6_<ZERO>', 'MOV_R7_<ZERO>'), ('STR_R4_[R2]', 'STM_R3_<SPECIAL>'), ('MOV_R1_R6', 'MOV_R0_R7'), ('STM_R3_<SPECIAL>', 'LDR_R3_[SP*None+<POSITIVE>]'), ('CMP_R0_<POSITIVE>', 'B_<NEAR>'), ('CMP_R0_<ZERO>', 'ADD_R6_R6_<NEGATIVE>'), ('CMP_R0_<ZERO>', 'B_<NEAR>'), ('CMP_R0_<ZERO>', 'MOV_R4_R8'), ('LDM_R10!_<SPECIAL>', 'ADD_R3_R4_<SPECIAL>'), ('MOV_R3_R10', 'MOV_R2_R5'), ('STR_R3_[SP*None+<POSITIVE>]', 'B_<NEAR>'), ('STR_R3_[SP*None+<POSITIVE>]', 'LDR_R3_[R0*None+<POSITIVE>]'), ('MOV_R3_<POSITIVE>', 'MOV_R3_<ZERO>'), ('MOV_R10_R3', 'LDR_R3_[SP*None+<POSITIVE>]'), ('MOV_R7_<ZERO>', 'STR_R9_[SP*None+<POSITIVE>]'), ('LDR_R3_[R0*None+<POSITIVE>]', 'CMP_R3_<ZERO>'), ('LDR_R3_[R0*None+<POSITIVE>]', 'CMP_R11_<ZERO>'), ('SUB_R5_R4_R3', 'MOV_R1_R5'), ('MOV_R5_R1', 'STR_R2_[SP*None+<POSITIVE>]'), ('LDR_R2_<MEM>', 'ADD_R1_PC_R1'), ('LDR_R2_<MEM>', 'ADD_R5_R11_<POSITIVE>'), ('ADD_R10_R10_<POSITIVE>', 'LDR_R3_[R5*None+<POSITIVE>]'), ('MOV_R0_R5', 'BL_<ECALL>'), ('PUSH_<SPECIAL>', 'LDR_R11_[R0*None+<POSITIVE>]'), ('ADD_R11_R5_<SPECIAL>', 'ADD_R10_R10_<POSITIVE>'), ('MOV_R1_<ZERO>', 'ADD_R0_R3_<POSITIVE>'), ('MOV_R2_R5', 'MOV_R0_R9'), ('MOV_R1_R7', 'BL_<ICALL>'), ('MOV_R1_<POSITIVE>', 'MOV_R0_R5'), ('MOV_R1_<POSITIVE>', 'STR_R0_[SP*None+<POSITIVE>]'), ('ADD_R5_R5_<POSITIVE>', 'B_<NEAR>'), ('MOV_R10_R11', 'MOV_R8_<ZERO>'), ('MOV_R8_<ZERO>', 'B_<NEAR>'), ('MOV_R8_<ZERO>', 'MOV_R4_<POSITIVE>'), ('MOV_R2_<SPECIAL>', 'MOV_R1_<ZERO>'), ('CMP_R4_<ZERO>', 'B_<NEAR>'), ('LDR_R0_[SP*None+<POSITIVE>]', 'BL_<ECALL>'), ('LDR_R0_[SP*None+<POSITIVE>]', 'ADD_R1_R1_<SPECIAL>'), ('CMP_R3_<ZERO>', 'B_<NEAR>'), ('CMP_R3_<ZERO>', 'MOV_R8_<ZERO>'), ('MOV_R3_<ZERO>', 'AND_R3_R3_<POSITIVE>'), ('MOV_R3_<ZERO>', 'BL_<ICALL>'), ('MOV_R3_<ZERO>', 'CMP_R4_R11'), ('CMP_R11_<ZERO>', 'MOV_R9_R0'), ('CMP_R11_<ZERO>', 'STR_R0_[SP*None+<POSITIVE>]'), ('CMP_R11_<ZERO>', 'MOV_R8_<ZERO>'), ('LDR_R3_[SP*None+<POSITIVE>]', 'ADD_R5_R3_<POSITIVE>'), ('LDR_R3_[SP*None+<POSITIVE>]', 'CMP_R5_<ZERO>'), ('LDR_R3_[SP*None+<POSITIVE>]', 'ADD_R4_R4_<POSITIVE>'), ('LDR_R3_[SP*None+<POSITIVE>]', 'MOV_R2_<SPECIAL>'), ('LDR_R3_[SP*None+<POSITIVE>]', 'CMP_R3_<ZERO>'), ('LDR_R3_[SP*None+<POSITIVE>]', 'CMP_R4_R3'), ('LDR_R3_[SP*None+<POSITIVE>]', 'ADD_R8_R8_<POSITIVE>'), ('LDR_R3_[SP*None+<POSITIVE>]', 'MOV_R0_R9'), ('LDR_R3_[SP*None+<POSITIVE>]', 'CMP_R3_R8'), ('CMP_R3_R4', 'B_<NEAR>'), ('MOV_R4_<POSITIVE>', 'MOV_R10_R3'), ('MOV_R4_<POSITIVE>', 'B_<NEAR>'), ('ADD_R4_R4_<POSITIVE>', 'CMP_R3_R4'), ('ADD_R4_R4_<POSITIVE>', 'CMP_R4_R10'), ('SUB_R1_R5_R11', 'MOV_R0_R9'), ('LDM_R3_<SPECIAL>', 'BL_<ICALL>'), ('MOV_R2_R7', 'MOV_R3_R6'), ('AND_R3_R3_<POSITIVE>', 'CMP_R3_<ZERO>'), ('STR_R11_[SP*None+<POSITIVE>]', 'LDR_R3_[SP*None+<POSITIVE>]'), ('BL_<ECALL>', 'MOV_R4_R0'), ('BL_<ECALL>', 'CMP_R0_<POSITIVE>'), ('BL_<ECALL>', 'MOV_R2_<ZERO>'), ('BL_<ECALL>', 'MOV_R1_<POSITIVE>'), ('BL_<ECALL>', 'STR_R0_[SP*None+<POSITIVE>]'), ('BL_<ECALL>', 'CMP_R11_<ZERO>'), ('BL_<ECALL>', 'MOV_R0_R8'), ('BL_<ECALL>', 'MOV_R3_R0'), ('BL_<ECALL>', 'CMP_R0_<ZERO>'), ('BL_<ECALL>', 'LDR_R0_[SP*None+<POSITIVE>]'), ('BL_<ECALL>', 'LDR_R3_[SP*None+<POSITIVE>]'), ('MOV_R0_R7', 'MOV_R2_<ZERO>'), ('ADD_R5_R3_<POSITIVE>', 'MOV_R1_R4'), ('LDR_R9_[SP*None+<POSITIVE>]', 'B_<NEAR>'), ('LDR_R6_[R5*None+<POSITIVE>]', 'LDR_R7_[R5*None+<ZERO>]'), ('SUB_SP_SP_<POSITIVE>', 'STR_R3_[SP*None+<POSITIVE>]')]",
      "edge_index": [
        [
          0,
          0,
          0,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          12,
          13,
          13,
          13,
          14,
          14,
          15,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          23,
          24,
          25,
          26,
          27,
          28,
          28,
          29,
          30,
          31,
          32,
          32,
          32,
          33,
          34,
          35,
          35,
          35,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          41,
          42,
          42,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          63,
          63,
          64,
          65,
          66,
          66,
          67,
          68,
          69,
          70,
          70,
          71,
          72,
          73,
          73,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          81,
          82,
          83,
          84,
          84,
          85,
          86,
          87,
          87,
          88,
          88,
          89,
          89,
          89,
          90,
          90,
          90,
          91,
          91,
          91,
          91,
          91,
          91,
          91,
          91,
          91,
          92,
          93,
          93,
          95,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          101,
          101,
          101,
          101,
          101,
          101,
          101,
          101,
          101,
          101,
          102,
          103,
          104,
          105,
          106
        ],
        [
          73,
          6,
          35,
          23,
          94,
          41,
          46,
          16,
          80,
          23,
          0,
          17,
          43,
          66,
          56,
          23,
          87,
          38,
          16,
          75,
          91,
          11,
          81,
          77,
          98,
          28,
          105,
          16,
          95,
          67,
          6,
          36,
          70,
          55,
          0,
          35,
          14,
          50,
          96,
          90,
          100,
          87,
          91,
          58,
          51,
          24,
          21,
          101,
          82,
          16,
          15,
          65,
          42,
          101,
          57,
          59,
          0,
          89,
          89,
          41,
          60,
          22,
          16,
          52,
          50,
          63,
          5,
          95,
          23,
          30,
          57,
          101,
          16,
          86,
          25,
          49,
          1,
          3,
          12,
          16,
          6,
          50,
          34,
          97,
          106,
          53,
          54,
          72,
          66,
          10,
          16,
          83,
          33,
          57,
          104,
          64,
          16,
          71,
          101,
          69,
          61,
          102,
          91,
          16,
          4,
          16,
          47,
          44,
          79,
          16,
          70,
          89,
          91,
          7,
          88,
          90,
          35,
          9,
          11,
          14,
          55,
          101,
          45,
          74,
          18,
          57,
          32,
          75,
          13,
          16,
          84,
          16,
          93,
          78,
          16,
          101,
          8,
          16,
          84,
          99,
          32,
          27,
          48,
          13,
          84,
          103,
          39,
          95,
          85,
          88,
          31,
          12,
          57,
          20,
          16,
          68,
          16,
          92,
          19,
          57,
          32,
          2,
          88,
          91,
          37,
          62,
          28,
          81,
          13,
          90,
          40,
          26,
          63,
          87,
          91,
          28,
          24,
          16,
          29,
          66
        ]
      ]
    },
    "pseudo_code_non_strip": "int __fastcall glp_eval_tab_row(glp_prob_0 *a1, unsigned __int8 *a2, int *ind, double *val)\n{\n  glp_prob_0 *v4; // r4\n  double v5; // r6\n  unsigned __int8 *v6; // r10\n  int m; // r11\n  int row_bind; // r4\n  bool v11; // cc\n  char v12; // r3\n  const unsigned __int8 *v13; // r3\n  int *v14; // r4\n  int v15; // r8\n  double *v16; // r5\n  int mat_col; // r0\n  double *v18; // r11\n  double *v19; // r10\n  int v20; // t1\n  double v21; // r0\n  double v22; // r0\n  void (*v24)(const char *, ...); // r0\n  void (*v25)(const char *, ...); // r0\n  glp_prob_0 *v26; // r5\n  double *v27; // r1\n  glp_errfunc v28; // r0\n  int v29; // [sp+4h] [bp-4Ch]\n  int v30; // [sp+8h] [bp-48h]\n  double *x; // [sp+Ch] [bp-44h]\n  double *v34; // [sp+1Ch] [bp-34h]\n  char *v35; // [sp+20h] [bp-30h]\n  unsigned __int8 *file; // [sp+24h] [bp-2Ch]\n\n  m = a1->m;\n  file = (unsigned __int8 *)a1->n;\n  if ( m && !a1->valid )\n  {\n    v28 = j_glp_error_(a2, (int)v4);\n    v28(\"glp_eval_tab_row: basis factorization does not exist\\n\");\n  }\n  v29 = (int)&file[m];\n  if ( (int)a2 <= 0 || (int)a2 > (int)&file[m] )\n  {\n    v24 = (void (*)(const char *, ...))j_glp_error_(a2, (int)v4);\n    v24(\"glp_eval_tab_row: k = %d; variable number out of range\", a2);\n    if ( m >= (int)a2 )\n    {\nLABEL_7:\n      row_bind = j_glp_get_row_bind(v4, (int)a2);\n      v11 = row_bind <= 0;\n      if ( row_bind )\n        goto LABEL_8;\nLABEL_35:\n      v25 = (void (*)(const char *, ...))j_glp_error_(a2, row_bind);\n      v25(\"glp_eval_tab_row: k = %d; variable must be basic\", a2);\n      goto LABEL_36;\n    }\n  }\n  else if ( m >= (int)a2 )\n  {\n    goto LABEL_7;\n  }\n  row_bind = j_glp_get_col_bind((glp_prob_0 *)a2, (int)v4);\n  v11 = row_bind <= 0;\n  if ( !row_bind )\n    goto LABEL_35;\nLABEL_8:\n  v12 = !v11;\n  if ( row_bind <= m )\n    v13 = (const unsigned __int8 *)(v12 & 1);\n  else\n    v13 = 0;\n  if ( v13 )\n  {\n    x = (double *)j_glp_alloc(SLODWORD(v5), m + 1);\n    v34 = (double *)j_glp_alloc(SLODWORD(v5), m + 1);\n    v35 = (char *)j_glp_alloc(SLODWORD(v5), m + 1);\nLABEL_16:\n    memset(x + 1, 0, 8 * m);\n    goto LABEL_17;\n  }\nLABEL_36:\n  j_glp_assert_((const unsigned __int8 *)row_bind, v13, 823);\n  x = (double *)j_glp_alloc(SLODWORD(v5), m + 1);\n  v34 = (double *)j_glp_alloc(SLODWORD(v5), m + 1);\n  v35 = (char *)j_glp_alloc(SLODWORD(v5), m + 1);\n  if ( m > 0 )\n    goto LABEL_16;\nLABEL_17:\n  v14 = (int *)&x[row_bind];\n  *v14 = 0;\n  v14[1] = 1072693248;\n  j_glp_btran(a1, x);\n  if ( v29 <= 0 )\n  {\n    v15 = 0;\n    goto LABEL_30;\n  }\n  if ( m <= 0 )\n  {\n    v15 = 0;\n    v14 = &dword_0 + 1;\nLABEL_22:\n    v30 = m;\n    do\n    {\n      if ( j_glp_get_col_stat((glp_prob_0 *)((char *)v14 - v30), (int)v14) != 1 )\n      {\n        v16 = v34;\n        mat_col = j_glp_get_mat_col((glp_prob_0 *)LODWORD(v5), SHIDWORD(v5), v14, v34);\n        if ( mat_col > 0 )\n        {\n          v5 = 0.0;\n          v18 = (double *)((char *)v34 + 4 * mat_col);\n          v19 = (double *)(v35 + 8);\n          do\n          {\n            v20 = *((_DWORD *)v16 + 1);\n            v16 = (double *)((char *)v16 + 4);\n            v21 = *v19++;\n            v22 = v5 + v21 * x[v20];\n            v5 = v22;\n          }\n          while ( v18 != v16 );\n          if ( v22 != 0.0 )\n          {\n            ind[++v15] = (int)v14;\n            val[v15] = v22;\n          }\n        }\n      }\n      v14 = (int *)((char *)v14 + 1);\n    }\n    while ( v29 >= (int)v14 );\n    goto LABEL_30;\n  }\n  if ( m < v29 )\n    v6 = (unsigned __int8 *)m;\n  v15 = 0;\n  v14 = &dword_0 + 1;\n  if ( m >= v29 )\n    v6 = &file[m];\n  v26 = (glp_prob_0 *)(x + 1);\n  do\n  {\n    if ( j_glp_get_row_stat(v26, (int)v14) != 1 )\n    {\n      HIDWORD(v5) = v26->pool;\n      LODWORD(v5) = (char *)v26->tree + 0x80000000;\n      if ( *(double *)&v26->pool != 0.0 )\n      {\n        v27 = &val[++v15];\n        ind[v15] = (int)v14;\n        *(_DWORD *)v27 = HIDWORD(v5);\n        *((_DWORD *)v27 + 1) = LODWORD(v5);\n      }\n    }\n    v14 = (int *)((char *)v14 + 1);\n    v26 = (glp_prob_0 *)((char *)v26 + 8);\n  }\n  while ( (int)v14 <= (int)v6 );\n  if ( (int)v14 <= v29 )\n    goto LABEL_22;\nLABEL_30:\n  if ( (int)file < v15 )\n    j_glp_assert_((const unsigned __int8 *)v14, file, 853);\n  release_0(v14);\n  release_0(v14);\n  release_0(v14);\n  return v15;\n}\n",
    "pseudo_code_refined": "'int __fastcall glp_eval_tab_row(_DWORD *a1, int a2, int a3, int a4)\\n{\\n  int v4; // r10\\n  int v5; // r11\\n  int row_bind; // r4\\n  bool v9; // cc\\n  char v10; // r3\\n  int v11; // r3\\n  _DWORD *v12; // r4\\n  int v13; // r8\\n  int v14; // r4\\n  int v15; // r5\\n  int mat_col; // r0\\n  __int64 v17; // r6\\n  int v18; // r11\\n  int *v19; // r10\\n  int v20; // t1\\n  int v21; // r0\\n  int v22; // r1\\n  __int64 v23; // r0\\n  void (*v25)(const char *, ...); // r0\\n  void (*v26)(const char *, ...); // r0\\n  _DWORD *v27; // r5\\n  int v28; // r7\\n  unsigned int v29; // r6\\n  _DWORD *v30; // r1\\n  void (__fastcall *v31)(const char *); // r0\\n  int v32; // [sp+4h] [bp-4Ch]\\n  int v33; // [sp+8h] [bp-48h]\\n  int v34; // [sp+Ch] [bp-44h]\\n  int v37; // [sp+1Ch] [bp-34"
  },
  {
    "function_name": "nlmsvc_invalidate_all",
    "function_name_in_strip": "sub_C01C1BBC",
    "comment": "remove all locks held for clientsRelease all locks held by NFS clients",
    "function_body": [
      "LDR R1, <MEM> =sub_C01C14F8",
      "MOV R0, <ZERO>",
      "B <NEAR>"
    ],
    "pseudo_code": "int sub_C01C1BBC()\n{\n  return sub_C01C1534(0, (int (__fastcall *)(int, int))sub_C01C14F8);\n}\n",
    "cfg": {
      "nodes": [
        "MOV_R0_<ZERO>",
        "LDR_R1_<MEM>",
        "B_<NEAR>",
        "PUSH_<SPECIAL>"
      ],
      "edges": "[('MOV_R0_<ZERO>', 'B_<NEAR>'), ('LDR_R1_<MEM>', 'MOV_R0_<ZERO>'), ('B_<NEAR>', 'PUSH_<SPECIAL>')]",
      "edge_index": [
        [
          0,
          1,
          2
        ],
        [
          2,
          0,
          3
        ]
      ]
    },
    "pseudo_code_non_strip": "int nlmsvc_invalidate_all()\n{\n  return nlm_traverse_files_constprop_2(0, (int (__fastcall *)(int, int))nlmsvc_is_client);\n}\n",
    "pseudo_code_refined": "'int nlmsvc_proc_exit()\\n{\\n  return seq_exit(0, (int (__fastcall *)(int, int))nlmsvc_proc_exit);\\n}\\n'"
  },
  {
    "function_name": "tm_year_str",
    "function_name_in_strip": "sub_13A2C",
    "comment": "Convert TM_YEAR, a year minus 1900, to a string that is numerically correct even if subtracting 1900 would overflow",
    "function_body": [
      "PUSH <SPECIAL>",
      "LDR R3, <MEM> =0xFFFFF894",
      "LDR R4, <MEM> =a02d02d",
      "SUB SP, SP, <POSITIVE>",
      "MOV R5, R1",
      "MOV R1, <POSITIVE>",
      "CMP R0, R3",
      "ADD R4, R4, <POSITIVE>",
      "MOV R6, R0",
      "BL <ICALL>",
      "EOR R3, R1, <SPECIAL>",
      "SUB R3, R3, <SPECIAL>",
      "MOV R0, R6",
      "MOV R1, <POSITIVE>",
      "STR R3, [SP+<POSITIVE>]",
      "BL <ICALL>",
      "ADD R0, R0, <POSITIVE>",
      "CMP R0, <ZERO>",
      "RSB R0, R0, <ZERO>",
      "STR R0, [SP+<ZERO>]",
      "MOV R3, R4",
      "MOV R0, R5",
      "MOV R2, <NEGATIVE>",
      "MOV R1, <POSITIVE>",
      "BL <ECALL> __sprintf_chk",
      "MOV R0, R5",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>"
    ],
    "pseudo_code": "int __fastcall sub_13A2C(int a1, int a2)\n{\n  char *v2; // r4\n  int v5; // r0\n\n  v2 = \"-%02d%02d\";\n  if ( a1 >= -1900 )\n    v2 = \"%02d%02d\";\n  sub_80308();\n  v5 = sub_8022C(a1, 100) + 19;\n  if ( v5 < 0 )\n    v5 = -v5;\n  _sprintf_chk(a2, 1, -1, v2, v5);\n  return a2;\n}\n",
    "cfg": {
      "nodes": [
        "LDR_R4_<MEM>",
        "MOV_R0_R6",
        "STR_R0_[SP*None+<ZERO>]",
        "RSB_R0_R0_<ZERO>",
        "ADD_R0_R0_<POSITIVE>",
        "CMP_R0_<ZERO>",
        "BL_<ICALL>",
        "MOV_R6_R0",
        "LDR_R3_<MEM>",
        "CMP_R0_R3",
        "MOV_R3_R4",
        "MOV_R1_<POSITIVE>",
        "MOV_R5_R1",
        "SUB_SP_SP_<POSITIVE>",
        "MOV_R0_R5",
        "POP_<SPECIAL>",
        "EOR_R3_R1_<SPECIAL>",
        "SUB_R3_R3_<SPECIAL>",
        "PUSH_<SPECIAL>",
        "BL_<ECALL>",
        "STR_R3_[SP*None+<POSITIVE>]",
        "MOV_R2_<NEGATIVE>",
        "ADD_SP_SP_<POSITIVE>",
        "ADD_R4_R4_<POSITIVE>"
      ],
      "edges": "[('LDR_R4_<MEM>', 'SUB_SP_SP_<POSITIVE>'), ('MOV_R0_R6', 'MOV_R1_<POSITIVE>'), ('STR_R0_[SP*None+<ZERO>]', 'MOV_R3_R4'), ('RSB_R0_R0_<ZERO>', 'STR_R0_[SP*None+<ZERO>]'), ('ADD_R0_R0_<POSITIVE>', 'CMP_R0_<ZERO>'), ('CMP_R0_<ZERO>', 'RSB_R0_R0_<ZERO>'), ('BL_<ICALL>', 'ADD_R0_R0_<POSITIVE>'), ('BL_<ICALL>', 'EOR_R3_R1_<SPECIAL>'), ('MOV_R6_R0', 'BL_<ICALL>'), ('LDR_R3_<MEM>', 'LDR_R4_<MEM>'), ('CMP_R0_R3', 'ADD_R4_R4_<POSITIVE>'), ('MOV_R3_R4', 'MOV_R0_R5'), ('MOV_R1_<POSITIVE>', 'BL_<ECALL>'), ('MOV_R1_<POSITIVE>', 'STR_R3_[SP*None+<POSITIVE>]'), ('MOV_R1_<POSITIVE>', 'CMP_R0_R3'), ('MOV_R5_R1', 'MOV_R1_<POSITIVE>'), ('SUB_SP_SP_<POSITIVE>', 'MOV_R5_R1'), ('MOV_R0_R5', 'ADD_SP_SP_<POSITIVE>'), ('MOV_R0_R5', 'MOV_R2_<NEGATIVE>'), ('EOR_R3_R1_<SPECIAL>', 'SUB_R3_R3_<SPECIAL>'), ('SUB_R3_R3_<SPECIAL>', 'MOV_R0_R6'), ('PUSH_<SPECIAL>', 'LDR_R3_<MEM>'), ('BL_<ECALL>', 'MOV_R0_R5'), ('STR_R3_[SP*None+<POSITIVE>]', 'BL_<ICALL>'), ('MOV_R2_<NEGATIVE>', 'MOV_R1_<POSITIVE>'), ('ADD_SP_SP_<POSITIVE>', 'POP_<SPECIAL>'), ('ADD_R4_R4_<POSITIVE>', 'MOV_R6_R0')]",
      "edge_index": [
        [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          6,
          7,
          8,
          9,
          10,
          11,
          11,
          11,
          12,
          13,
          14,
          14,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23
        ],
        [
          13,
          11,
          10,
          2,
          5,
          3,
          4,
          16,
          6,
          0,
          23,
          14,
          19,
          20,
          9,
          11,
          12,
          22,
          21,
          17,
          1,
          8,
          14,
          6,
          11,
          15,
          7
        ]
      ]
    },
    "pseudo_code_non_strip": "const unsigned __int8 *__fastcall tm_year_str(int a1, int a2)\n{\n  char *v2; // r4\n  int v4; // r0\n  unsigned int v6; // [sp+4h] [bp-14h]\n\n  v2 = \"-%02d%02d\";\n  if ( a1 >= -1900 )\n    v2 = \"%02d%02d\";\n  v6 = abs32(a1 % 100);\n  v4 = a1 / 100 + 19;\n  if ( v4 < 0 )\n    v4 = -v4;\n  _sprintf_chk(a2, 1, -1, v2, v4, v6);\n  return (const unsigned __int8 *)a2;\n}\n",
    "pseudo_code_refined": "'void __fastcall version_etc_ar(\\n        const unsigned __int8 *command_name,\\n        unsigned __int8 **argv)\\n{\\n  char *v2; // r4\\n  int v5; // r0\\n\\n  v2 = \"-%02d%02d\";\\n  if ( command_name >= -1900 )\\n    v2 = \"%02d%02d\";\\n  version_etc_ar(\\n      command_name,\\n      -1,\\n      v2,\\n      v5);\\n}\\n'"
  },
  {
    "function_name": "genev_init",
    "function_name_in_strip": "sub_12D2C",
    "comment": "Initialize generic event table ",
    "function_body": [
      "PUSH <SPECIAL>",
      "LDR R4, <MEM> =dword_4488C",
      "LDR R12, [R4+<ZERO>]",
      "CMP R12, <ZERO>",
      "POP <SPECIAL>",
      "MOV R5, <ZERO>",
      "LDR R6, <MEM> =off_44864",
      "LDR R0, [R6+<ZERO>]",
      "CMP R0, <ZERO>",
      "B <NEAR>",
      "LDR R3, [R6+<POSITIVE>]",
      "CMP R3, R12",
      "B <NEAR>",
      "LDR R3, <MEM> =off_44864",
      "B <NEAR>",
      "LDR R2, [R3+<POSITIVE>]",
      "CMP R2, R12",
      "B <NEAR>",
      "LDR R0, [R3+<POSITIVE>]",
      "ADD R3, R3, <POSITIVE>",
      "CMP R0, <ZERO>",
      "B <NEAR>",
      "MOV R1, R4",
      "MOV R2, <ZERO>",
      "BL <ICALL>",
      "LDR R12, [R4+<POSITIVE>]",
      "ADD R5, R5, <POSITIVE>",
      "CMP R12, R5",
      "B <NEAR>",
      "POP <SPECIAL>"
    ],
    "pseudo_code": "int sub_12D2C()\n{\n  int *v0; // r4\n  int v1; // r12\n  int v2; // r5\n  char **v3; // r3\n  char *v4; // r0\n  int result; // r0\n  int v6; // t1\n\n  v0 = &dword_4488C;\n  v1 = dword_4488C;\n  if ( dword_4488C > 0 )\n  {\n    v2 = 0;\n    do\n    {\n      if ( off_44864 && dword_44868 != v1 )\n      {\n        v3 = &off_44864;\n        do\n        {\n          v4 = v3[2];\n          v3 += 2;\n        }\n        while ( v4 && v3[1] != (char *)v1 );\n      }\n      result = sub_156E0();\n      v6 = v0[2];\n      v0 += 2;\n      v1 = v6;\n      ++v2;\n    }\n    while ( v6 > v2 );\n  }\n  return result;\n}\n",
    "cfg": {
      "nodes": [
        "LDR_R12_[R4*None+<ZERO>]",
        "MOV_R5_<ZERO>",
        "CMP_R3_R12",
        "MOV_R2_<ZERO>",
        "LDR_R3_[R6*None+<POSITIVE>]",
        "LDR_R0_[R3*None+<POSITIVE>]",
        "B_<NEAR>",
        "LDR_R6_<MEM>",
        "CMP_R2_R12",
        "MOV_R1_R4",
        "LDR_R0_[R6*None+<ZERO>]",
        "LDR_R2_[R3*None+<POSITIVE>]",
        "BL_<ICALL>",
        "LDR_R12_[R4*None+<POSITIVE>]",
        "PUSH_<SPECIAL>",
        "CMP_R12_R5",
        "CMP_R12_<ZERO>",
        "LDR_R4_<MEM>",
        "ADD_R5_R5_<POSITIVE>",
        "ADD_R3_R3_<POSITIVE>",
        "CMP_R0_<ZERO>",
        "POP_<SPECIAL>",
        "LDR_R3_<MEM>"
      ],
      "edges": "[('LDR_R12_[R4*None+<ZERO>]', 'CMP_R12_<ZERO>'), ('MOV_R5_<ZERO>', 'LDR_R6_<MEM>'), ('CMP_R3_R12', 'B_<NEAR>'), ('MOV_R2_<ZERO>', 'BL_<ICALL>'), ('LDR_R3_[R6*None+<POSITIVE>]', 'CMP_R3_R12'), ('LDR_R0_[R3*None+<POSITIVE>]', 'ADD_R3_R3_<POSITIVE>'), ('B_<NEAR>', 'MOV_R1_R4'), ('B_<NEAR>', 'POP_<SPECIAL>'), ('B_<NEAR>', 'LDR_R2_[R3*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R3_[R6*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R3_<MEM>'), ('B_<NEAR>', 'LDR_R0_[R3*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R0_[R6*None+<ZERO>]'), ('LDR_R6_<MEM>', 'LDR_R0_[R6*None+<ZERO>]'), ('CMP_R2_R12', 'B_<NEAR>'), ('MOV_R1_R4', 'MOV_R2_<ZERO>'), ('LDR_R0_[R6*None+<ZERO>]', 'CMP_R0_<ZERO>'), ('LDR_R2_[R3*None+<POSITIVE>]', 'CMP_R2_R12'), ('BL_<ICALL>', 'LDR_R12_[R4*None+<POSITIVE>]'), ('LDR_R12_[R4*None+<POSITIVE>]', 'ADD_R5_R5_<POSITIVE>'), ('PUSH_<SPECIAL>', 'LDR_R4_<MEM>'), ('CMP_R12_R5', 'B_<NEAR>'), ('CMP_R12_<ZERO>', 'POP_<SPECIAL>'), ('LDR_R4_<MEM>', 'LDR_R12_[R4*None+<ZERO>]'), ('ADD_R5_R5_<POSITIVE>', 'CMP_R12_R5'), ('ADD_R3_R3_<POSITIVE>', 'CMP_R0_<ZERO>'), ('CMP_R0_<ZERO>', 'B_<NEAR>'), ('POP_<SPECIAL>', 'MOV_R5_<ZERO>'), ('LDR_R3_<MEM>', 'B_<NEAR>')]",
      "edge_index": [
        [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22
        ],
        [
          16,
          7,
          6,
          12,
          2,
          19,
          9,
          21,
          11,
          4,
          22,
          5,
          10,
          10,
          6,
          3,
          20,
          8,
          13,
          18,
          17,
          6,
          21,
          0,
          15,
          20,
          6,
          1,
          6
        ]
      ]
    },
    "pseudo_code_non_strip": "void genev_init()\n{\n  const unsigned __int8 *v0; // r7\n  int v1; // r8\n  event_mask *v2; // r4\n  int gen_mask; // r12\n  event_mask *v4; // r5\n  transtab *v5; // r3\n  unsigned __int8 *name; // r0\n  int v7; // t1\n\n  v2 = genev_xlat;\n  gen_mask = genev_xlat[0].gen_mask;\n  if ( genev_xlat[0].gen_mask > 0 )\n  {\n    v4 = 0;\n    do\n    {\n      if ( genev_transtab[0].name && dword_44868 != gen_mask )\n      {\n        v5 = genev_transtab;\n        do\n        {\n          name = v5[1].name;\n          ++v5;\n        }\n        while ( name && v5->tok != gen_mask );\n      }\n      defevt(v0, v4, v1);\n      v7 = v2[1].gen_mask;\n      ++v2;\n      gen_mask = v7;\n      v4 = (event_mask *)((char *)v4 + 1);\n    }\n    while ( v7 > (int)v4 );\n  }\n}\n",
    "pseudo_code_refined": "'void scribble_init()\\n{\\n  scrib_buf_t *v0; // r4\\n  scrib_buf_t *v1; // r12\\n  int v2; // r5\\n  scrib_buf_t *v3; // r3\\n  scrib_buf_t *v4; // r0\\n\\n  v0 = &scrib_buf_0;\\n  v1 = scrib_buf_0;\\n  if ( scrib_buf_0 > 0 )\\n  {\\n    v2 = 0;\\n    do\\n    {\\n      if ( scrib_buf_0 && scrib_buf_size != v1 )\\n      {\\n        v3 = &scrib_buf_0;\\n        do\\n        {\\n          v4 = v3[2];\\n          v3 += 2;\\n        }\\n        while ( v4 && v3[1] != (char *)v1 );\\n      }\\n      scrib_submit_buffers();\\n      v6 = v0[2];\\n      v0 += 2;\\n      v1 = v6;\\n      ++v2;\\n    }\\n    while ( v6 > v2 );\\n  }\\n}\\n'"
  },
  {
    "function_name": "udp_ioctl",
    "function_name_in_strip": "sub_C0391740",
    "comment": "IOCTL requests applicable to the UDP protocol ",
    "function_body": [
      "LDR R12, <MEM> =0x5411",
      "PUSH <SPECIAL>",
      "CMP R1, R12",
      "MOV R4, R2",
      "B <NEAR>",
      "LDR R2, <MEM> =0x541B",
      "CMP R1, R2",
      "B <NEAR>",
      "BL <ICALL>",
      "MOV R3, SP",
      "BIC R3, R3, <POSITIVE>",
      "BIC R3, R3, <POSITIVE>",
      "LDR R1, [R3+<POSITIVE>]",
      "SUB R2, R0, <ZERO>",
      "SUB R2, R2, <POSITIVE>",
      "MOV R0, R4",
      "SUB R1, R1, <POSITIVE>",
      "BL <ICALL>",
      "POP <SPECIAL>",
      "LDR R0, <MEM> =0xFFFFFDFD",
      "POP <SPECIAL>",
      "MOV R3, SP",
      "BIC R1, R3, <POSITIVE>",
      "BIC R1, R1, <POSITIVE>",
      "LDR R2, [R0+<POSITIVE>]",
      "LDR R1, [R1+<POSITIVE>]",
      "SUB R2, R2, <POSITIVE>",
      "MOV R0, R4",
      "SUB R1, R1, <POSITIVE>",
      "BL <ICALL>",
      "POP <SPECIAL>"
    ],
    "pseudo_code": "int __fastcall sub_C0391740(int a1, int a2, unsigned int *a3)\n{\n  int v4; // r0\n  struct task_struct *current; // r3\n  unsigned int v6; // r2\n\n  if ( a2 == 21521 )\n    return sub_C0219998(a3, *((_DWORD *)get_current() + 2) - 1, *(_DWORD *)(a1 + 160) - 1);\n  if ( a2 != 21531 )\n    return -515;\n  v4 = sub_C03914C4(a1);\n  current = get_current();\n  v6 = v4;\n  if ( v4 )\n    v6 = v4 - 8;\n  return sub_C0219998(a3, *((_DWORD *)current + 2) - 1, v6);\n}\n",
    "cfg": {
      "nodes": [
        "LDR_R2_<MEM>",
        "BIC_R1_R3_<POSITIVE>",
        "MOV_R3_SP",
        "POP_<SPECIAL>",
        "LDR_R1_[R3*None+<POSITIVE>]",
        "SUB_R1_R1_<POSITIVE>",
        "LDR_R2_[R0*None+<POSITIVE>]",
        "CMP_R1_R2",
        "BL_<ICALL>",
        "LDR_R1_[R1*None+<POSITIVE>]",
        "LDR_R12_<MEM>",
        "MOV_R4_R2",
        "BIC_R3_R3_<POSITIVE>",
        "B_<NEAR>",
        "BIC_R1_R1_<POSITIVE>",
        "SUB_R2_R0_<ZERO>",
        "MOV_R0_R4",
        "PUSH_<SPECIAL>",
        "CMP_R1_R12",
        "LDR_R0_<MEM>",
        "SUB_R2_R2_<POSITIVE>"
      ],
      "edges": "[('LDR_R2_<MEM>', 'CMP_R1_R2'), ('BIC_R1_R3_<POSITIVE>', 'BIC_R1_R1_<POSITIVE>'), ('MOV_R3_SP', 'BIC_R3_R3_<POSITIVE>'), ('MOV_R3_SP', 'BIC_R1_R3_<POSITIVE>'), ('LDR_R1_[R3*None+<POSITIVE>]', 'SUB_R2_R0_<ZERO>'), ('SUB_R1_R1_<POSITIVE>', 'BL_<ICALL>'), ('LDR_R2_[R0*None+<POSITIVE>]', 'LDR_R1_[R1*None+<POSITIVE>]'), ('CMP_R1_R2', 'B_<NEAR>'), ('BL_<ICALL>', 'MOV_R3_SP'), ('BL_<ICALL>', 'POP_<SPECIAL>'), ('LDR_R1_[R1*None+<POSITIVE>]', 'SUB_R2_R2_<POSITIVE>'), ('LDR_R12_<MEM>', 'PUSH_<SPECIAL>'), ('MOV_R4_R2', 'B_<NEAR>'), ('BIC_R3_R3_<POSITIVE>', 'LDR_R1_[R3*None+<POSITIVE>]'), ('BIC_R3_R3_<POSITIVE>', 'BIC_R3_R3_<POSITIVE>'), ('B_<NEAR>', 'LDR_R0_<MEM>'), ('B_<NEAR>', 'MOV_R3_SP'), ('B_<NEAR>', 'LDR_R2_<MEM>'), ('B_<NEAR>', 'BL_<ICALL>'), ('BIC_R1_R1_<POSITIVE>', 'LDR_R2_[R0*None+<POSITIVE>]'), ('SUB_R2_R0_<ZERO>', 'SUB_R2_R2_<POSITIVE>'), ('MOV_R0_R4', 'SUB_R1_R1_<POSITIVE>'), ('PUSH_<SPECIAL>', 'CMP_R1_R12'), ('CMP_R1_R12', 'MOV_R4_R2'), ('LDR_R0_<MEM>', 'POP_<SPECIAL>'), ('SUB_R2_R2_<POSITIVE>', 'MOV_R0_R4')]",
      "edge_index": [
        [
          0,
          1,
          2,
          2,
          4,
          5,
          6,
          7,
          8,
          8,
          9,
          10,
          11,
          12,
          12,
          13,
          13,
          13,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20
        ],
        [
          7,
          14,
          12,
          1,
          15,
          8,
          9,
          13,
          2,
          3,
          20,
          17,
          13,
          4,
          12,
          19,
          2,
          0,
          8,
          6,
          20,
          5,
          18,
          11,
          3,
          16
        ]
      ]
    },
    "pseudo_code_non_strip": "int __fastcall udp_ioctl(int a1, int a2, unsigned int *a3)\n{\n  int packet_length; // r0\n  struct task_struct *current; // r3\n  unsigned int v6; // r2\n\n  if ( a2 == 21521 )\n    return _put_user_4(a3, *((_DWORD *)get_current() + 2) - 1, *(_DWORD *)(a1 + 160) - 1);\n  if ( a2 != 21531 )\n    return -515;\n  packet_length = first_packet_length(a1);\n  current = get_current();\n  v6 = packet_length;\n  if ( packet_length )\n    v6 = packet_length - 8;\n  return _put_user_4(a3, *((_DWORD *)current + 2) - 1, v6);\n}\n",
    "pseudo_code_refined": "'int __fastcall skb_copy_and_csum_datagram_msg(int a1, int a2, unsigned int *a3)\\n{\\n  int v4; // r0\\n  struct task_struct *current; // r3\\n  unsigned int v6; // r2\\n\\n  if ( a2 == 21521 )\\n    return memcpy(a3, *((_DWORD *)get_current() + 2) - 1, *(_DWORD *)(a1 + 160) - 1);\\n  if ( a2 != 21531 )\\n    return -515;\\n  v4 = skb_checksum(a1);\\n  current = get_current();\\n  v6 = v4;\\n  if ( v4 )\\n    v6 = v4 - 8;\\n  return memcpy(a3, *((_DWORD *)current + 2) - 1, v6);\\n}\\n'"
  },
  {
    "function_name": "rmtstatus",
    "function_name_in_strip": "sub_1A96C",
    "comment": "show status on remote machine ",
    "function_body": [
      "LDR R2, <MEM> =aStatS",
      "LDR R3, <MEM> =aStat",
      "CMP R0, <POSITIVE>",
      "LDR R1, [R1+<POSITIVE>]",
      "MOV R0, R2",
      "MOV R0, R3",
      "B <NEAR>"
    ],
    "pseudo_code": "int __fastcall sub_1A96C(int a1, int a2)\n{\n  int v2; // r1\n\n  v2 = *(_DWORD *)(a2 + 4);\n  if ( a1 <= 1 )\n    return sub_1CA24(\"STAT\");\n  else\n    return sub_1CA24(\"STAT %s\", v2);\n}\n",
    "cfg": {
      "nodes": [
        "CMP_R0_<POSITIVE>",
        "LDR_R1_[R1*None+<POSITIVE>]",
        "MOV_R0_R3",
        "LDR_R2_<MEM>",
        "MOV_R0_R2",
        "LDR_R3_<MEM>",
        "B_<NEAR>",
        "PUSH_<SPECIAL>"
      ],
      "edges": "[('CMP_R0_<POSITIVE>', 'LDR_R1_[R1*None+<POSITIVE>]'), ('LDR_R1_[R1*None+<POSITIVE>]', 'MOV_R0_R2'), ('MOV_R0_R3', 'B_<NEAR>'), ('LDR_R2_<MEM>', 'LDR_R3_<MEM>'), ('MOV_R0_R2', 'MOV_R0_R3'), ('LDR_R3_<MEM>', 'CMP_R0_<POSITIVE>'), ('B_<NEAR>', 'PUSH_<SPECIAL>')]",
      "edge_index": [
        [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        [
          1,
          4,
          6,
          5,
          2,
          0,
          7
        ]
      ]
    },
    "pseudo_code_non_strip": "void __fastcall rmtstatus(int argc, unsigned __int8 **argv)\n{\n  unsigned __int8 *v2; // r1\n\n  v2 = argv[1];\n  if ( argc <= 1 )\n    command(\"STAT\");\n  else\n    command(\"STAT %s\", v2);\n}\n",
    "pseudo_code_refined": "'void __fastcall print_stats(int a1, int a2)\\n{\\n  int v2; // r1\\n\\n  v2 = *(_DWORD *)(a2 + 4);\\n  if ( a1 <= 1 )\\n    goto LABEL_3;\\n  else\\n    goto LABEL_3;\\n}\\n'"
  },
  {
    "function_name": "gsl_ieee_set_mode",
    "function_name_in_strip": "gsl_ieee_set_mode",
    "comment": "This is a copy of fp-netbsd",
    "function_body": [
      "PUSH <SPECIAL>",
      "CMP R0, <POSITIVE>",
      "SUB SP, SP, <POSITIVE>",
      "B <NEAR>",
      "CMP R0, <POSITIVE>",
      "B <NEAR>",
      "CMP R0, <POSITIVE>",
      "B <NEAR>",
      "CMP R1, <POSITIVE>",
      "MOV R4, R2",
      "B <NEAR>",
      "CMP R1, <POSITIVE>",
      "B <NEAR>",
      "CMP R1, <POSITIVE>",
      "MOV R0, <ZERO>",
      "MOV R0, <POSITIVE>",
      "BL <ECALL> fesetround",
      "AND R3, R4, <POSITIVE>",
      "CMP R3, <ZERO>",
      "MOV R3, <POSITIVE>",
      "MOV R3, <POSITIVE>",
      "STR R3, [SP+<POSITIVE>]",
      "MOV R3, <POSITIVE>",
      "MOV R3, <ZERO>",
      "STR R3, [SP+<POSITIVE>]",
      "MOV R3, <POSITIVE>",
      "MOV R3, <POSITIVE>",
      "MOV R0, <POSITIVE>",
      "STR R3, [SP+<POSITIVE>]",
      "MOV R0, <POSITIVE>",
      "MOV R1, <POSITIVE>",
      "MOV R1, <POSITIVE>",
      "MOV R2, <POSITIVE>",
      "MOV R2, <POSITIVE>",
      "MOV R6, <POSITIVE>",
      "MOV R6, <POSITIVE>",
      "MOV R5, <POSITIVE>",
      "MOV R5, <POSITIVE>",
      "MOV LR, <POSITIVE>",
      "MOV LR, <POSITIVE>",
      "MOV R12, <POSITIVE>",
      "MOV R12, <POSITIVE>",
      "MOV R11, <POSITIVE>",
      "MOV R11, <POSITIVE>",
      "MOV R10, <POSITIVE>",
      "MOV R10, <POSITIVE>",
      "MOV R9, <POSITIVE>",
      "MOV R9, <POSITIVE>",
      "MOV R8, <POSITIVE>",
      "MOV R8, <POSITIVE>",
      "MOV R7, <POSITIVE>",
      "MOV R7, <POSITIVE>",
      "MOV R3, <POSITIVE>",
      "MOV R3, <POSITIVE>",
      "TST R4, <POSITIVE>",
      "B <NEAR>",
      "TST R4, <POSITIVE>",
      "B <NEAR>",
      "LDM SP, <SPECIAL>",
      "MOV R0, R11",
      "MOV R1, R10",
      "MOV R2, R9",
      "MOV R6, R8",
      "MOV R3, R7",
      "LDR R12, [SP+<POSITIVE>]",
      "AND R7, R4, <POSITIVE>",
      "CMP R7, <ZERO>",
      "MOV R2, LR",
      "MOV R3, R12",
      "AND R12, R4, <POSITIVE>",
      "MOV R0, R6",
      "MOV R1, R5",
      "CMP R12, <ZERO>",
      "MOV R3, R2",
      "MOV R0, R1",
      "TST R4, <POSITIVE>",
      "MOV R0, R3",
      "BL <ECALL> feenableexcept",
      "MOV R0, <ZERO>",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>",
      "LDR R1, <MEM> =(aFpGnuc99C - 0xA31F4)",
      "LDR R0, <MEM> =(aSinglePrecisio_0 - 0xA31EC)",
      "MOV R3, <POSITIVE>",
      "ADD R0, PC, R0",
      "MOV R2, <POSITIVE>",
      "ADD R1, PC, R1",
      "BL <ECALL> j_gsl_error",
      "MOV R0, <POSITIVE>",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>",
      "LDR R1, <MEM> =(aFpGnuc99C - 0xA3218)",
      "LDR R0, <MEM> =(aExtendedPrecis_0 - 0xA321C)",
      "MOV R3, <POSITIVE>",
      "MOV R2, <POSITIVE>",
      "ADD R1, PC, R1",
      "ADD R0, PC, R0",
      "BL <ECALL> j_gsl_error",
      "MOV R0, <POSITIVE>",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>",
      "LDR R1, <MEM> =(aFpGnuc99C - 0xA3240)",
      "LDR R0, <MEM> =(aDoublePrecisio_0 - 0xA3244)",
      "MOV R3, <POSITIVE>",
      "MOV R2, <POSITIVE>",
      "ADD R1, PC, R1",
      "ADD R0, PC, R0",
      "BL <ECALL> j_gsl_error",
      "MOV R0, <POSITIVE>",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>",
      "MOV R0, <POSITIVE>",
      "BL <ECALL> fesetround",
      "B <NEAR>",
      "MOV R0, <POSITIVE>",
      "BL <ECALL> fesetround",
      "B <NEAR>",
      "LDR R1, <MEM> =(aFpGnuc99C - 0xA3284)",
      "LDR R0, <MEM> =(aDenormalizedOp - 0xA327C)",
      "MOV R3, <POSITIVE>",
      "ADD R0, PC, R0",
      "MOV R2, <POSITIVE>",
      "ADD R1, PC, R1",
      "BL <ECALL> j_gsl_error",
      "MOV R0, <POSITIVE>",
      "B <NEAR>"
    ],
    "pseudo_code": "int __fastcall gsl_ieee_set_mode(int a1, int a2, char a3)\n{\n  int v3; // r5\n  int v4; // r6\n  int v5; // r7\n  int v6; // r8\n  int v7; // r9\n  int v8; // r10\n  int v9; // r11\n  int v10; // lr\n  int v12; // r0\n  int v13; // r0\n  int v14; // r1\n  int v15; // r2\n  int v16; // r12\n  int v17; // r3\n  int v18; // r3\n  int v20; // [sp+4h] [bp-34h]\n  int v21; // [sp+Ch] [bp-2Ch]\n\n  switch ( a1 )\n  {\n    case 2:\n      j_gsl_error(\"double precision rounding is not supported by <fenv.h>\", \"fp-gnuc99.c\", 41, 23);\n      return 23;\n    case 3:\n      j_gsl_error(\"extended precision rounding is not supported by <fenv.h>\", \"fp-gnuc99.c\", 45, 23);\n      return 23;\n    case 1:\n      j_gsl_error(\"single precision rounding is not supported by <fenv.h>\", \"fp-gnuc99.c\", 37, 23);\n      return 23;\n    default:\n      if ( a2 == 3 )\n      {\n        v13 = fesetround(0x400000);\n      }\n      else if ( a2 == 4 )\n      {\n        v13 = fesetround(12582912);\n      }\n      else\n      {\n        if ( a2 == 2 )\n          v12 = 0x800000;\n        else\n          v12 = 0;\n        v13 = fesetround(v12);\n      }\n      if ( (a3 & 1) != 0 )\n        v17 = 16;\n      else\n        v17 = 17;\n      v20 = v17;\n      if ( (a3 & 1) != 0 )\n        v18 = 8;\n      else\n        v18 = 9;\n      if ( (a3 & 1) != 0 )\n        v13 = 30;\n      v21 = v18;\n      if ( (a3 & 1) != 0 )\n        v14 = 22;\n      else\n        v13 = 31;\n      if ( (a3 & 1) != 0 )\n        v15 = 6;\n      else\n        v14 = 23;\n      if ( (a3 & 1) != 0 )\n        v4 = 26;\n      else\n        v15 = 7;\n      if ( (a3 & 1) != 0 )\n        v3 = 18;\n      else\n        v4 = 27;\n      if ( (a3 & 1) != 0 )\n        v10 = 2;\n      else\n        v3 = 19;\n      if ( (a3 & 1) != 0 )\n        v16 = 10;\n      else\n        v10 = 3;\n      if ( (a3 & 1) != 0 )\n        v9 = 28;\n      else\n        v16 = 11;\n      if ( (a3 & 1) != 0 )\n        v8 = 20;\n      else\n        v9 = 29;\n      if ( (a3 & 1) != 0 )\n        v7 = 4;\n      else\n        v8 = 21;\n      if ( (a3 & 1) != 0 )\n        v6 = 24;\n      else\n        v7 = 5;\n      if ( (a3 & 1) != 0 )\n        v5 = 12;\n      else\n        v6 = 25;\n      if ( (a3 & 1) != 0 )\n        v18 = 14;\n      else\n        v5 = 13;\n      if ( (a3 & 1) == 0 )\n        v18 = 15;\n      if ( (a3 & 2) != 0 )\n      {\n        if ( (a3 & 4) != 0 )\n        {\n          v3 = v20;\n          v10 = (a3 & 1) == 0;\n          v13 = v9;\n          v14 = v8;\n          v15 = v7;\n          v4 = v6;\n          v18 = v5;\n          v16 = v21;\n        }\n        if ( (a3 & 8) != 0 )\n        {\n          v15 = v10;\n          v18 = v16;\n        }\n        if ( (a3 & 8) != 0 )\n        {\n          v13 = v4;\n          v14 = v3;\n        }\n        if ( (a3 & 0x10) != 0 )\n        {\n          v18 = v15;\n          v13 = v14;\n        }\n        if ( (a3 & 0x20) == 0 )\n          v13 = v18;\n        feenableexcept(v13, v14, v15, v18);\n        return 0;\n      }\n      else\n      {\n        j_gsl_error(\n          \"denormalized operand exception not supported by <fenv.h>. Use 'mask-denormalized' to work around this.\",\n          \"fp-gnuc99.c\",\n          125,\n          23);\n        return 23;\n      }\n  }\n}\n",
    "cfg": {
      "nodes": [
        "MOV_LR_<POSITIVE>",
        "TST_R4_<POSITIVE>",
        "AND_R12_R4_<POSITIVE>",
        "MOV_R7_<POSITIVE>",
        "PUSH_<SPECIAL>",
        "MOV_R12_<POSITIVE>",
        "MOV_R8_<POSITIVE>",
        "CMP_R0_<POSITIVE>",
        "ADD_R0_PC_R0",
        "MOV_R4_R2",
        "MOV_R3_R7",
        "B_<NEAR>",
        "LDM_SP_<SPECIAL>",
        "SUB_SP_SP_<POSITIVE>",
        "MOV_R1_<POSITIVE>",
        "MOV_R3_R12",
        "MOV_R0_R6",
        "MOV_R3_R2",
        "CMP_R3_<ZERO>",
        "MOV_R3_<POSITIVE>",
        "CMP_R12_<ZERO>",
        "MOV_R0_R1",
        "MOV_R0_<POSITIVE>",
        "MOV_R10_<POSITIVE>",
        "BL_<ECALL>",
        "ADD_SP_SP_<POSITIVE>",
        "STR_R3_[SP*None+<POSITIVE>]",
        "AND_R7_R4_<POSITIVE>",
        "LDR_R0_<MEM>",
        "MOV_R9_<POSITIVE>",
        "MOV_R3_<ZERO>",
        "MOV_R2_R9",
        "AND_R3_R4_<POSITIVE>",
        "MOV_R6_<POSITIVE>",
        "MOV_R1_R5",
        "MOV_R5_<POSITIVE>",
        "MOV_R2_<POSITIVE>",
        "LDR_R1_<MEM>",
        "LDR_R12_[SP*None+<POSITIVE>]",
        "MOV_R1_R10",
        "MOV_R11_<POSITIVE>",
        "MOV_R0_R3",
        "ADD_R1_PC_R1",
        "POP_<SPECIAL>",
        "CMP_R7_<ZERO>",
        "MOV_R0_R11",
        "CMP_R1_<POSITIVE>",
        "MOV_R2_LR",
        "MOV_R6_R8",
        "MOV_R0_<ZERO>"
      ],
      "edges": "[('MOV_LR_<POSITIVE>', 'MOV_LR_<POSITIVE>'), ('MOV_LR_<POSITIVE>', 'MOV_R12_<POSITIVE>'), ('TST_R4_<POSITIVE>', 'MOV_R0_R3'), ('TST_R4_<POSITIVE>', 'B_<NEAR>'), ('AND_R12_R4_<POSITIVE>', 'MOV_R0_R6'), ('MOV_R7_<POSITIVE>', 'MOV_R7_<POSITIVE>'), ('MOV_R7_<POSITIVE>', 'MOV_R3_<POSITIVE>'), ('PUSH_<SPECIAL>', 'CMP_R0_<POSITIVE>'), ('MOV_R12_<POSITIVE>', 'MOV_R11_<POSITIVE>'), ('MOV_R12_<POSITIVE>', 'MOV_R12_<POSITIVE>'), ('MOV_R8_<POSITIVE>', 'MOV_R7_<POSITIVE>'), ('MOV_R8_<POSITIVE>', 'MOV_R8_<POSITIVE>'), ('CMP_R0_<POSITIVE>', 'B_<NEAR>'), ('CMP_R0_<POSITIVE>', 'SUB_SP_SP_<POSITIVE>'), ('ADD_R0_PC_R0', 'BL_<ECALL>'), ('ADD_R0_PC_R0', 'MOV_R2_<POSITIVE>'), ('MOV_R4_R2', 'B_<NEAR>'), ('MOV_R3_R7', 'LDR_R12_[SP*None+<POSITIVE>]'), ('B_<NEAR>', 'LDM_SP_<SPECIAL>'), ('B_<NEAR>', 'AND_R7_R4_<POSITIVE>'), ('B_<NEAR>', 'CMP_R1_<POSITIVE>'), ('B_<NEAR>', 'MOV_R0_<POSITIVE>'), ('B_<NEAR>', 'AND_R3_R4_<POSITIVE>'), ('B_<NEAR>', 'LDR_R1_<MEM>'), ('B_<NEAR>', 'ADD_SP_SP_<POSITIVE>'), ('B_<NEAR>', 'TST_R4_<POSITIVE>'), ('B_<NEAR>', 'CMP_R0_<POSITIVE>'), ('LDM_SP_<SPECIAL>', 'MOV_R0_R11'), ('SUB_SP_SP_<POSITIVE>', 'B_<NEAR>'), ('MOV_R1_<POSITIVE>', 'MOV_R2_<POSITIVE>'), ('MOV_R1_<POSITIVE>', 'MOV_R1_<POSITIVE>'), ('MOV_R3_R12', 'AND_R12_R4_<POSITIVE>'), ('MOV_R0_R6', 'MOV_R1_R5'), ('MOV_R3_R2', 'MOV_R0_R1'), ('CMP_R3_<ZERO>', 'MOV_R3_<POSITIVE>'), ('MOV_R3_<POSITIVE>', 'MOV_R2_<POSITIVE>'), ('MOV_R3_<POSITIVE>', 'MOV_R0_<POSITIVE>'), ('MOV_R3_<POSITIVE>', 'STR_R3_[SP*None+<POSITIVE>]'), ('MOV_R3_<POSITIVE>', 'MOV_R3_<ZERO>'), ('MOV_R3_<POSITIVE>', 'ADD_R0_PC_R0'), ('MOV_R3_<POSITIVE>', 'MOV_R3_<POSITIVE>'), ('MOV_R3_<POSITIVE>', 'TST_R4_<POSITIVE>'), ('CMP_R12_<ZERO>', 'MOV_R3_R2'), ('MOV_R0_R1', 'TST_R4_<POSITIVE>'), ('MOV_R0_<POSITIVE>', 'STR_R3_[SP*None+<POSITIVE>]'), ('MOV_R0_<POSITIVE>', 'MOV_R1_<POSITIVE>'), ('MOV_R0_<POSITIVE>', 'B_<NEAR>'), ('MOV_R0_<POSITIVE>', 'ADD_SP_SP_<POSITIVE>'), ('MOV_R0_<POSITIVE>', 'BL_<ECALL>'), ('MOV_R10_<POSITIVE>', 'MOV_R10_<POSITIVE>'), ('MOV_R10_<POSITIVE>', 'MOV_R9_<POSITIVE>'), ('BL_<ECALL>', 'MOV_R0_<ZERO>'), ('BL_<ECALL>', 'B_<NEAR>'), ('BL_<ECALL>', 'AND_R3_R4_<POSITIVE>'), ('BL_<ECALL>', 'MOV_R0_<POSITIVE>'), ('ADD_SP_SP_<POSITIVE>', 'POP_<SPECIAL>'), ('STR_R3_[SP*None+<POSITIVE>]', 'MOV_R0_<POSITIVE>'), ('STR_R3_[SP*None+<POSITIVE>]', 'MOV_R3_<POSITIVE>'), ('AND_R7_R4_<POSITIVE>', 'CMP_R7_<ZERO>'), ('LDR_R0_<MEM>', 'MOV_R3_<POSITIVE>'), ('MOV_R9_<POSITIVE>', 'MOV_R9_<POSITIVE>'), ('MOV_R9_<POSITIVE>', 'MOV_R8_<POSITIVE>'), ('MOV_R3_<ZERO>', 'STR_R3_[SP*None+<POSITIVE>]'), ('MOV_R2_R9', 'MOV_R6_R8'), ('AND_R3_R4_<POSITIVE>', 'CMP_R3_<ZERO>'), ('MOV_R6_<POSITIVE>', 'MOV_R5_<POSITIVE>'), ('MOV_R6_<POSITIVE>', 'MOV_R6_<POSITIVE>'), ('MOV_R1_R5', 'CMP_R12_<ZERO>'), ('MOV_R5_<POSITIVE>', 'MOV_R5_<POSITIVE>'), ('MOV_R5_<POSITIVE>', 'MOV_LR_<POSITIVE>'), ('MOV_R2_<POSITIVE>', 'MOV_R2_<POSITIVE>'), ('MOV_R2_<POSITIVE>', 'ADD_R1_PC_R1'), ('MOV_R2_<POSITIVE>', 'MOV_R6_<POSITIVE>'), ('LDR_R1_<MEM>', 'LDR_R0_<MEM>'), ('LDR_R12_[SP*None+<POSITIVE>]', 'AND_R7_R4_<POSITIVE>'), ('MOV_R1_R10', 'MOV_R2_R9'), ('MOV_R11_<POSITIVE>', 'MOV_R11_<POSITIVE>'), ('MOV_R11_<POSITIVE>', 'MOV_R10_<POSITIVE>'), ('MOV_R0_R3', 'BL_<ECALL>'), ('ADD_R1_PC_R1', 'BL_<ECALL>'), ('ADD_R1_PC_R1', 'ADD_R0_PC_R0'), ('CMP_R7_<ZERO>', 'MOV_R2_LR'), ('MOV_R0_R11', 'MOV_R1_R10'), ('CMP_R1_<POSITIVE>', 'B_<NEAR>'), ('CMP_R1_<POSITIVE>', 'MOV_R0_<ZERO>'), ('CMP_R1_<POSITIVE>', 'MOV_R4_R2'), ('MOV_R2_LR', 'MOV_R3_R12'), ('MOV_R6_R8', 'MOV_R3_R7'), ('MOV_R0_<ZERO>', 'ADD_SP_SP_<POSITIVE>'), ('MOV_R0_<ZERO>', 'MOV_R0_<POSITIVE>')]",
      "edge_index": [
        [
          0,
          0,
          1,
          1,
          2,
          3,
          3,
          4,
          5,
          5,
          6,
          6,
          7,
          7,
          8,
          8,
          9,
          10,
          11,
          11,
          11,
          11,
          11,
          11,
          11,
          11,
          11,
          12,
          13,
          14,
          14,
          15,
          16,
          17,
          18,
          19,
          19,
          19,
          19,
          19,
          19,
          19,
          20,
          21,
          22,
          22,
          22,
          22,
          22,
          23,
          23,
          24,
          24,
          24,
          24,
          25,
          26,
          26,
          27,
          28,
          29,
          29,
          30,
          31,
          32,
          33,
          33,
          34,
          35,
          35,
          36,
          36,
          36,
          37,
          38,
          39,
          40,
          40,
          41,
          42,
          42,
          44,
          45,
          46,
          46,
          46,
          47,
          48,
          49,
          49
        ],
        [
          0,
          5,
          41,
          11,
          16,
          3,
          19,
          7,
          40,
          5,
          3,
          6,
          11,
          13,
          24,
          36,
          11,
          38,
          12,
          27,
          46,
          22,
          32,
          37,
          25,
          1,
          7,
          45,
          11,
          36,
          14,
          2,
          34,
          21,
          19,
          36,
          22,
          26,
          30,
          8,
          19,
          1,
          17,
          1,
          26,
          14,
          11,
          25,
          24,
          23,
          29,
          49,
          11,
          32,
          22,
          43,
          22,
          19,
          44,
          19,
          29,
          6,
          26,
          48,
          18,
          35,
          33,
          20,
          35,
          0,
          36,
          42,
          33,
          28,
          27,
          31,
          40,
          23,
          24,
          24,
          8,
          47,
          39,
          11,
          49,
          9,
          15,
          10,
          25,
          22
        ]
      ]
    },
    "pseudo_code_non_strip": "int __fastcall gsl_ieee_set_mode(int precision, int rounding, char a3)\n{\n  const unsigned __int8 *v3; // r5\n  int v4; // r6\n  int v5; // r7\n  int v6; // r8\n  int v7; // r9\n  int v8; // r10\n  int v9; // r11\n  int v10; // lr\n  int v12; // r0\n  int v13; // r0\n  int v14; // r1\n  int v15; // r2\n  int v16; // r12\n  int v17; // r3\n  int v18; // r3\n  const unsigned __int8 *v20; // [sp+4h] [bp-34h]\n  int v21; // [sp+Ch] [bp-2Ch]\n\n  switch ( precision )\n  {\n    case 2:\n      j_gsl_error(v3, \"fp-gnuc99.c\", 41, 23);\n      return 23;\n    case 3:\n      j_gsl_error(v3, \"fp-gnuc99.c\", 45, 23);\n      return 23;\n    case 1:\n      j_gsl_error(v3, \"fp-gnuc99.c\", 37, 23);\n      return 23;\n    default:\n      if ( rounding == 3 )\n      {\n        v13 = fesetround(0x400000);\n      }\n      else if ( rounding == 4 )\n      {\n        v13 = fesetround(12582912);\n      }\n      else\n      {\n        if ( rounding == 2 )\n          v12 = 0x800000;\n        else\n          v12 = 0;\n        v13 = fesetround(v12);\n      }\n      if ( (a3 & 1) != 0 )\n        v17 = 16;\n      else\n        v17 = 17;\n      v20 = (const unsigned __int8 *)v17;\n      if ( (a3 & 1) != 0 )\n        v18 = 8;\n      else\n        v18 = 9;\n      if ( (a3 & 1) != 0 )\n        v13 = 30;\n      v21 = v18;\n      if ( (a3 & 1) != 0 )\n        v14 = 22;\n      else\n        v13 = 31;\n      if ( (a3 & 1) != 0 )\n        v15 = 6;\n      else\n        v14 = 23;\n      if ( (a3 & 1) != 0 )\n        v4 = 26;\n      else\n        v15 = 7;\n      if ( (a3 & 1) != 0 )\n        v3 = (const unsigned __int8 *)&word_12;\n      else\n        v4 = 27;\n      if ( (a3 & 1) != 0 )\n        v10 = 2;\n      else\n        v3 = (const unsigned __int8 *)&word_12 + 1;\n      if ( (a3 & 1) != 0 )\n        v16 = 10;\n      else\n        v10 = 3;\n      if ( (a3 & 1) != 0 )\n        v9 = 28;\n      else\n        v16 = 11;\n      if ( (a3 & 1) != 0 )\n        v8 = 20;\n      else\n        v9 = 29;\n      if ( (a3 & 1) != 0 )\n        v7 = 4;\n      else\n        v8 = 21;\n      if ( (a3 & 1) != 0 )\n        v6 = 24;\n      else\n        v7 = 5;\n      if ( (a3 & 1) != 0 )\n        v5 = 12;\n      else\n        v6 = 25;\n      if ( (a3 & 1) != 0 )\n        v18 = 14;\n      else\n        v5 = 13;\n      if ( (a3 & 1) == 0 )\n        v18 = 15;\n      if ( (a3 & 2) != 0 )\n      {\n        if ( (a3 & 4) != 0 )\n        {\n          v3 = v20;\n          v10 = (a3 & 1) == 0;\n          v13 = v9;\n          v14 = v8;\n          v15 = v7;\n          v4 = v6;\n          v18 = v5;\n          v16 = v21;\n        }\n        if ( (a3 & 8) != 0 )\n        {\n          v15 = v10;\n          v18 = v16;\n        }\n        if ( (a3 & 8) != 0 )\n        {\n          v13 = v4;\n          v14 = (int)v3;\n        }\n        if ( (a3 & 0x10) != 0 )\n        {\n          v18 = v15;\n          v13 = v14;\n        }\n        if ( (a3 & 0x20) == 0 )\n          v13 = v18;\n        feenableexcept(v13, v14, v15, v18);\n        return 0;\n      }\n      else\n      {\n        j_gsl_error(v3, \"fp-gnuc99.c\", 125, 23);\n        return 23;\n      }\n  }\n}\n",
    "pseudo_code_refined": "'int __fastcall gsl_ieee_set_mode(int a1, int a2, char a3)\\n{\\n  int v3; // r5\\n  int v4; // r6\\n  int v5; // r7\\n  int v6; // r8\\n  int v7; // r9\\n  int v8; // r10\\n  int v9; // r11\\n  int v10; // lr\\n  int v12; // r0\\n  int v13; // r0\\n  int v14; // r1\\n  int v15; // r2\\n  int v16; // r12\\n  int v17; // r3\\n  int v18; // r3\\n  int v20; // [sp+4h] [bp-34h]\\n  int v21; // [sp+Ch] [bp-2Ch]\\n\\n  switch ( a1 )\\n  {\\n    case 2:\\n      j_gsl_error((const unsigned __int8 *)HIDWORD(a2), \"fp-gnuc99.c\", 41, 23);\\n      return 23;\\n    case 3:\\n      j_gsl_error((const unsigned __int8 *)HIDWORD(a2), \"fp-gnuc99.c\", 45, 23);\\n      return 23;\\n    case 1:\\n      j_gsl_error((const unsigned __int8 *)HIDWORD(a2), \"fp-gnuc99.c\", 37, 23);\\n      return 23;\\n    default:\\n      if ( a2 == 3 )\\n      {\\n        v13 = fesetround(0x400000"
  },
  {
    "function_name": "xmemdup",
    "function_name_in_strip": "sub_3DEC4",
    "comment": "Clone an object P of size S, with error checking",
    "function_body": [
      "PUSH <SPECIAL>",
      "MOV R4, R1",
      "MOV R5, R0",
      "MOV R0, R1",
      "BL <ECALL> malloc",
      "MOV R3, R4",
      "MOV R3, <POSITIVE>",
      "CMP R0, <ZERO>",
      "MOV R3, <ZERO>",
      "CMP R3, <ZERO>",
      "B <NEAR>",
      "MOV R2, R4",
      "MOV R1, R5",
      "POP <SPECIAL>",
      "B <NEAR>",
      "BL <ICALL>"
    ],
    "pseudo_code": "void *__fastcall sub_3DEC4(const void *a1, size_t size)\n{\n  void *v4; // r0\n  int v5; // r1\n  size_t v6; // r3\n\n  v4 = malloc(size);\n  v6 = size;\n  if ( size )\n    v6 = 1;\n  if ( v4 )\n    v6 = 0;\n  if ( v6 )\n    sub_3DF38(v4, v5);\n  return memcpy(v4, a1, size);\n}\n",
    "cfg": {
      "nodes": [
        "MOV_R4_R1",
        "MOV_R5_R0",
        "POP_<SPECIAL>",
        "MOV_R2_R4",
        "PUSH_<SPECIAL>",
        "B_<NEAR>",
        "CMP_R0_<ZERO>",
        "MOV_R3_R4",
        "BL_<ECALL>",
        "MOV_R1_R5",
        "MOV_R0_R1",
        "MOV_R3_<ZERO>",
        "CMP_R3_<ZERO>",
        "MOV_R3_<POSITIVE>",
        "BL_<ICALL>",
        "ADR_R12_<POSITIVE>"
      ],
      "edges": "[('MOV_R4_R1', 'MOV_R5_R0'), ('MOV_R5_R0', 'MOV_R0_R1'), ('POP_<SPECIAL>', 'B_<NEAR>'), ('MOV_R2_R4', 'MOV_R1_R5'), ('PUSH_<SPECIAL>', 'MOV_R4_R1'), ('B_<NEAR>', 'MOV_R2_R4'), ('B_<NEAR>', 'BL_<ICALL>'), ('B_<NEAR>', 'ADR_R12_<POSITIVE>'), ('CMP_R0_<ZERO>', 'MOV_R3_<ZERO>'), ('MOV_R3_R4', 'MOV_R3_<POSITIVE>'), ('BL_<ECALL>', 'MOV_R3_R4'), ('MOV_R1_R5', 'POP_<SPECIAL>'), ('MOV_R0_R1', 'BL_<ECALL>'), ('MOV_R3_<ZERO>', 'CMP_R3_<ZERO>'), ('CMP_R3_<ZERO>', 'B_<NEAR>'), ('MOV_R3_<POSITIVE>', 'CMP_R0_<ZERO>')]",
      "edge_index": [
        [
          0,
          1,
          2,
          3,
          4,
          5,
          5,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13
        ],
        [
          1,
          10,
          5,
          9,
          0,
          3,
          14,
          15,
          11,
          13,
          7,
          2,
          8,
          12,
          5,
          6
        ]
      ]
    },
    "pseudo_code_non_strip": "void *__fastcall xmemdup(const void *a1, size_t a2)\n{\n  void *v4; // r0\n  int v5; // r3\n\n  v4 = malloc(a2);\n  v5 = a2;\n  if ( a2 )\n    v5 = 1;\n  if ( v4 )\n    v5 = 0;\n  if ( v5 )\n    xalloc_die();\n  return memcpy(v4, a1, a2);\n}\n",
    "pseudo_code_refined": "'void *__fastcall xmemdup(const void *a1, size_t a2)\\n{\\n  void *v4; // r0\\n  int v5; // r1\\n  size_t v6; // r3\\n\\n  v4 = malloc(a2);\\n  v6 = a2;\\n  if ( a2 )\\n    v6 = 1;\\n  if ( v4 )\\n    v6 = 0;\\n  if ( v6 )\\n    xalloc_die();\\n  return memcpy(v4, a1, a2);\\n}\\n'"
  },
  {
    "function_name": "__sb_end_write",
    "function_name_in_strip": "sub_C00F7FB4",
    "comment": "This is an internal function, please use sb_end_{write,pagefault,intwrite}instead",
    "function_body": [
      "PUSH <SPECIAL>",
      "ADD R1, R0, <SPECIAL>",
      "ADD R1, R1, <POSITIVE>",
      "LDRD R2, R3, [R1+<ZERO>]",
      "SUB R4, R2, <POSITIVE>",
      "SBC R5, R3, <ZERO>",
      "STRD R4, R5, [R1+<ZERO>]",
      "LDR R3, [R0+<POSITIVE>]",
      "ADD R0, R0, <POSITIVE>",
      "CMP R0, R3",
      "B <NEAR>",
      "POP <SPECIAL>",
      "MOV R3, <ZERO>",
      "MOV R2, <POSITIVE>",
      "MOV R1, <POSITIVE>",
      "B <NEAR>",
      "POP <SPECIAL>",
      "BX LR"
    ],
    "pseudo_code": "_DWORD **__fastcall sub_C00F7FB4(int a1, int a2)\n{\n  _DWORD **v2; // r3\n  _DWORD **result; // r0\n\n  --*(_QWORD *)(a1 + 8 * a2 + 352);\n  v2 = *(_DWORD ***)(a1 + 384);\n  result = (_DWORD **)(a1 + 384);\n  if ( result != v2 )\n    return sub_C0065388(result, 3, 1, 0);\n  return result;\n}\n",
    "cfg": {
      "nodes": [
        "LDRD_R2_R3_[R1*None+<ZERO>]",
        "POP_<SPECIAL>",
        "ADD_R1_R1_<POSITIVE>",
        "SUB_R4_R2_<POSITIVE>",
        "ADD_R0_R0_<POSITIVE>",
        "PUSH_<SPECIAL>",
        "LDR_R3_[R0*None+<POSITIVE>]",
        "ADD_R1_R0_<SPECIAL>",
        "CMP_R0_R3",
        "MOV_R3_<ZERO>",
        "MOV_R1_<POSITIVE>",
        "STRD_R4_R5_[R1*None+<ZERO>]",
        "MOV_R2_<POSITIVE>",
        "SBC_R5_R3_<ZERO>",
        "BX_LR",
        "B_<NEAR>"
      ],
      "edges": "[('LDRD_R2_R3_[R1*None+<ZERO>]', 'SUB_R4_R2_<POSITIVE>'), ('POP_<SPECIAL>', 'MOV_R3_<ZERO>'), ('POP_<SPECIAL>', 'BX_LR'), ('ADD_R1_R1_<POSITIVE>', 'LDRD_R2_R3_[R1*None+<ZERO>]'), ('SUB_R4_R2_<POSITIVE>', 'SBC_R5_R3_<ZERO>'), ('ADD_R0_R0_<POSITIVE>', 'CMP_R0_R3'), ('PUSH_<SPECIAL>', 'ADD_R1_R0_<SPECIAL>'), ('LDR_R3_[R0*None+<POSITIVE>]', 'ADD_R0_R0_<POSITIVE>'), ('ADD_R1_R0_<SPECIAL>', 'ADD_R1_R1_<POSITIVE>'), ('CMP_R0_R3', 'B_<NEAR>'), ('MOV_R3_<ZERO>', 'MOV_R2_<POSITIVE>'), ('MOV_R1_<POSITIVE>', 'B_<NEAR>'), ('STRD_R4_R5_[R1*None+<ZERO>]', 'LDR_R3_[R0*None+<POSITIVE>]'), ('MOV_R2_<POSITIVE>', 'MOV_R1_<POSITIVE>'), ('SBC_R5_R3_<ZERO>', 'STRD_R4_R5_[R1*None+<ZERO>]'), ('B_<NEAR>', 'POP_<SPECIAL>'), ('B_<NEAR>', 'PUSH_<SPECIAL>')]",
      "edge_index": [
        [
          0,
          1,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          15,
          15
        ],
        [
          3,
          9,
          14,
          0,
          13,
          8,
          7,
          4,
          2,
          15,
          12,
          15,
          6,
          10,
          11,
          1,
          5
        ]
      ]
    },
    "pseudo_code_non_strip": "_DWORD **__fastcall _sb_end_write(int a1, int a2)\n{\n  _DWORD **v2; // r3\n  _DWORD **result; // r0\n\n  --*(_QWORD *)(a1 + 8 * a2 + 352);\n  v2 = *(_DWORD ***)(a1 + 384);\n  result = (_DWORD **)(a1 + 384);\n  if ( result != v2 )\n    return _wake_up(result, 3, 1, 0);\n  return result;\n}\n",
    "pseudo_code_refined": "'_DWORD **__fastcall up_read(int a1, int a2)\\n{\\n  _DWORD **v2; // r3\\n  _DWORD **result; // r0\\n\\n  --*(_QWORD *)(a1 + 8 * a2 + 352);\\n  v2 = *(_DWORD ***)(a1 + 384);\\n  result = (_DWORD **)(a1 + 384);\\n  if ( result != v2 )\\n    return _wake_up(result, 3, 1, 0);\\n  return result;\\n}\\n'"
  },
  {
    "function_name": "gsl_histogram_clone",
    "function_name_in_strip": "gsl_histogram_clone",
    "comment": "gsl_histogram_duplicate:duplicate an histogram creatingan identical new one ",
    "function_body": [
      "PUSH <SPECIAL>",
      "LDR R4, [R0+<ZERO>]",
      "LDR R1, [R0+<POSITIVE>]",
      "MOV R5, R0",
      "MOV R0, R4",
      "BL <ECALL> j_gsl_histogram_calloc_range",
      "SUB R6, R0, <ZERO>",
      "B <NEAR>",
      "CMP R4, <ZERO>",
      "B <NEAR>",
      "LDR R3, [R5+<POSITIVE>]",
      "LDR R2, [R6+<POSITIVE>]",
      "ADD R0, R3, <SPECIAL>",
      "LDM R3!, <SPECIAL>",
      "CMP R3, R0",
      "STM R2!, <SPECIAL>",
      "B <NEAR>",
      "MOV R0, R6",
      "POP <SPECIAL>",
      "LDR R1, <MEM> =(aCopyC - 0xA01B0)",
      "LDR R0, <MEM> =(aFailedToAlloca_35 - 0xA01B4)",
      "MOV R3, <POSITIVE>",
      "MOV R2, <POSITIVE>",
      "ADD R1, PC, R1",
      "ADD R0, PC, R0",
      "BL <ECALL> j_gsl_error",
      "B <NEAR>"
    ],
    "pseudo_code": "_DWORD *__fastcall gsl_histogram_clone(int a1)\n{\n  int v1; // r4\n  _DWORD *v3; // r0\n  _DWORD *v4; // r6\n  int *v5; // r3\n  _DWORD *v6; // r2\n  int *v7; // r0\n  int v8; // r4\n  int v9; // r5\n\n  v1 = *(_DWORD *)a1;\n  v3 = j_gsl_histogram_calloc_range(*(_DWORD *)a1, *(_DWORD **)(a1 + 4));\n  v4 = v3;\n  if ( v3 )\n  {\n    if ( v1 )\n    {\n      v5 = *(int **)(a1 + 8);\n      v6 = (_DWORD *)v3[2];\n      v7 = &v5[2 * v1];\n      do\n      {\n        v8 = *v5;\n        v9 = v5[1];\n        v5 += 2;\n        *v6 = v8;\n        v6[1] = v9;\n        v6 += 2;\n      }\n      while ( v5 != v7 );\n    }\n  }\n  else\n  {\n    j_gsl_error(\"failed to allocate space for histogram struct\", \"copy.c\", 81, 8);\n  }\n  return v4;\n}\n",
    "cfg": {
      "nodes": [
        "PUSH_<SPECIAL>",
        "SUB_R6_R0_<ZERO>",
        "LDM_R3!_<SPECIAL>",
        "ADD_R0_PC_R0",
        "B_<NEAR>",
        "MOV_R0_R6",
        "LDR_R3_[R5*None+<POSITIVE>]",
        "MOV_R3_<POSITIVE>",
        "BL_<ECALL>",
        "CMP_R4_<ZERO>",
        "CMP_R3_R0",
        "LDR_R1_[R0*None+<POSITIVE>]",
        "LDR_R0_<MEM>",
        "MOV_R2_<POSITIVE>",
        "LDR_R1_<MEM>",
        "MOV_R0_R4",
        "ADD_R1_PC_R1",
        "POP_<SPECIAL>",
        "ADD_R0_R3_<SPECIAL>",
        "STM_R2!_<SPECIAL>",
        "LDR_R2_[R6*None+<POSITIVE>]",
        "MOV_R5_R0",
        "LDR_R4_[R0*None+<ZERO>]"
      ],
      "edges": "[('PUSH_<SPECIAL>', 'LDR_R4_[R0*None+<ZERO>]'), ('SUB_R6_R0_<ZERO>', 'B_<NEAR>'), ('LDM_R3!_<SPECIAL>', 'CMP_R3_R0'), ('ADD_R0_PC_R0', 'BL_<ECALL>'), ('B_<NEAR>', 'CMP_R4_<ZERO>'), ('B_<NEAR>', 'LDR_R3_[R5*None+<POSITIVE>]'), ('B_<NEAR>', 'MOV_R0_R6'), ('B_<NEAR>', 'LDR_R1_<MEM>'), ('B_<NEAR>', 'LDM_R3!_<SPECIAL>'), ('MOV_R0_R6', 'POP_<SPECIAL>'), ('LDR_R3_[R5*None+<POSITIVE>]', 'LDR_R2_[R6*None+<POSITIVE>]'), ('MOV_R3_<POSITIVE>', 'MOV_R2_<POSITIVE>'), ('BL_<ECALL>', 'B_<NEAR>'), ('BL_<ECALL>', 'SUB_R6_R0_<ZERO>'), ('CMP_R4_<ZERO>', 'B_<NEAR>'), ('CMP_R3_R0', 'STM_R2!_<SPECIAL>'), ('LDR_R1_[R0*None+<POSITIVE>]', 'MOV_R5_R0'), ('LDR_R0_<MEM>', 'MOV_R3_<POSITIVE>'), ('MOV_R2_<POSITIVE>', 'ADD_R1_PC_R1'), ('LDR_R1_<MEM>', 'LDR_R0_<MEM>'), ('MOV_R0_R4', 'BL_<ECALL>'), ('ADD_R1_PC_R1', 'ADD_R0_PC_R0'), ('ADD_R0_R3_<SPECIAL>', 'LDM_R3!_<SPECIAL>'), ('STM_R2!_<SPECIAL>', 'B_<NEAR>'), ('LDR_R2_[R6*None+<POSITIVE>]', 'ADD_R0_R3_<SPECIAL>'), ('MOV_R5_R0', 'MOV_R0_R4'), ('LDR_R4_[R0*None+<ZERO>]', 'LDR_R1_[R0*None+<POSITIVE>]')]",
      "edge_index": [
        [
          0,
          1,
          2,
          3,
          4,
          4,
          4,
          4,
          4,
          5,
          6,
          7,
          8,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          18,
          19,
          20,
          21,
          22
        ],
        [
          22,
          4,
          10,
          8,
          9,
          6,
          5,
          14,
          2,
          17,
          20,
          13,
          4,
          1,
          4,
          19,
          21,
          7,
          16,
          12,
          8,
          3,
          2,
          4,
          18,
          15,
          11
        ]
      ]
    },
    "pseudo_code_non_strip": "gsl_histogram *__fastcall gsl_histogram_clone(const unsigned __int8 *a1)\n{\n  size_t v1; // r6\n  double *v2; // r7\n  int v3; // r4\n  gsl_histogram *v5; // r0\n  gsl_histogram *v6; // r6\n  int *v7; // r3\n  double *bin; // r2\n  int *v9; // r0\n  int v10; // r4\n  int v11; // r5\n\n  v3 = *(_DWORD *)a1;\n  v5 = j_gsl_histogram_calloc_range(v1, v2);\n  v6 = v5;\n  if ( v5 )\n  {\n    if ( v3 )\n    {\n      v7 = (int *)*((_DWORD *)a1 + 2);\n      bin = v5->bin;\n      v9 = &v7[2 * v3];\n      do\n      {\n        v10 = *v7;\n        v11 = v7[1];\n        v7 += 2;\n        *(_DWORD *)bin = v10;\n        *((_DWORD *)bin++ + 1) = v11;\n      }\n      while ( v7 != v9 );\n    }\n  }\n  else\n  {\n    j_gsl_error(a1, \"copy.c\", 81, 8);\n  }\n  return v6;\n}\n",
    "pseudo_code_refined": "'gsl_histogram *__fastcall gsl_histogram_clone(const gsl_histogram *a1)\\n{\\n  size_t n; // r4\\n  double *bin; // r0\\n  double *v4; // r6\\n  double *v5; // r3\\n  double *v6; // r2\\n  double *v7; // r0\\n  double v8; // r4\\n  double v9; // r5\\n\\n  n = a1->n;\\n  bin = j_gsl_histogram_calloc_range(a1, a1->n);\\n  v4 = bin;\\n  if ( bin )\\n  {\\n    if ( n )\\n    {\\n      v5 = a1->bin;\\n      v6 = &bin[n];\\n      v7 = &v5[n];\\n      do\\n      {\\n        v8 = *v5++;\\n        *v6 = v8;\\n        *v6 = v9;\\n        ++v6;\\n      }\\n      while ( v5 != v7 );\\n    }\\n  }\\n  else\\n  {\\n    j_gsl_error((const unsigned __int8 *)a1, \"copy.c\", 81, 8);\\n  }\\n  return (gsl_histogram *)v4;\\n}\\n'"
  },
  {
    "function_name": "module_param_sysfs_remove",
    "function_name_in_strip": "sub_C00525D4",
    "comment": "remove sysfs support for one module",
    "function_body": [
      "LDR R1, [R0+<POSITIVE>]",
      "CMP R1, <ZERO>",
      "BX LR",
      "PUSH <SPECIAL>",
      "MOV R4, R0",
      "ADD R1, R1, <POSITIVE>",
      "ADD R0, R0, <POSITIVE>",
      "BL <ICALL>",
      "LDR R0, [R4+<POSITIVE>]",
      "CMP R0, <ZERO>",
      "B <NEAR>",
      "LDR R0, [R0+<POSITIVE>]",
      "BL <ICALL>",
      "LDR R0, [R4+<POSITIVE>]",
      "BL <ICALL>",
      "MOV R3, <ZERO>",
      "STR R3, [R4+<POSITIVE>]",
      "POP <SPECIAL>"
    ],
    "pseudo_code": "int __fastcall sub_C00525D4(int result)\n{\n  int v1; // r1\n  int v2; // r4\n  int v3; // r0\n\n  v1 = *(_DWORD *)(result + 116);\n  if ( v1 )\n  {\n    v2 = result;\n    sub_C0171D0C(result + 72, v1 + 4);\n    v3 = *(_DWORD *)(v2 + 116);\n    if ( v3 )\n    {\n      sub_C00ECA80(*(_DWORD *)(v3 + 12));\n      v3 = *(_DWORD *)(v2 + 116);\n    }\n    result = sub_C00ECA80(v3);\n    *(_DWORD *)(v2 + 116) = 0;\n  }\n  return result;\n}\n",
    "cfg": {
      "nodes": [
        "LDR_R0_[R4*None+<POSITIVE>]",
        "POP_<SPECIAL>",
        "LDR_R1_[R0*None+<POSITIVE>]",
        "ADD_R1_R1_<POSITIVE>",
        "ADD_R0_R0_<POSITIVE>",
        "MOV_R4_R0",
        "PUSH_<SPECIAL>",
        "BL_<ICALL>",
        "MOV_R3_<ZERO>",
        "CMP_R0_<ZERO>",
        "LDR_R0_[R0*None+<POSITIVE>]",
        "STR_R3_[R4*None+<POSITIVE>]",
        "BX_LR",
        "B_<NEAR>",
        "CMP_R1_<ZERO>"
      ],
      "edges": "[('LDR_R0_[R4*None+<POSITIVE>]', 'CMP_R0_<ZERO>'), ('LDR_R0_[R4*None+<POSITIVE>]', 'BL_<ICALL>'), ('LDR_R1_[R0*None+<POSITIVE>]', 'CMP_R1_<ZERO>'), ('ADD_R1_R1_<POSITIVE>', 'ADD_R0_R0_<POSITIVE>'), ('ADD_R0_R0_<POSITIVE>', 'BL_<ICALL>'), ('MOV_R4_R0', 'ADD_R1_R1_<POSITIVE>'), ('PUSH_<SPECIAL>', 'MOV_R4_R0'), ('BL_<ICALL>', 'MOV_R3_<ZERO>'), ('BL_<ICALL>', 'LDR_R0_[R4*None+<POSITIVE>]'), ('MOV_R3_<ZERO>', 'STR_R3_[R4*None+<POSITIVE>]'), ('CMP_R0_<ZERO>', 'B_<NEAR>'), ('LDR_R0_[R0*None+<POSITIVE>]', 'BL_<ICALL>'), ('STR_R3_[R4*None+<POSITIVE>]', 'POP_<SPECIAL>'), ('BX_LR', 'PUSH_<SPECIAL>'), ('B_<NEAR>', 'LDR_R0_[R0*None+<POSITIVE>]'), ('B_<NEAR>', 'BL_<ICALL>'), ('CMP_R1_<ZERO>', 'BX_LR')]",
      "edge_index": [
        [
          0,
          0,
          2,
          3,
          4,
          5,
          6,
          7,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          13,
          14
        ],
        [
          9,
          7,
          14,
          4,
          7,
          3,
          5,
          8,
          0,
          11,
          13,
          7,
          1,
          6,
          10,
          7,
          12
        ]
      ]
    },
    "pseudo_code_non_strip": "int __fastcall module_param_sysfs_remove(int result)\n{\n  int v1; // r1\n  int v2; // r4\n  int v3; // r0\n\n  v1 = *(_DWORD *)(result + 116);\n  if ( v1 )\n  {\n    v2 = result;\n    sysfs_remove_group(result + 72, v1 + 4);\n    v3 = *(_DWORD *)(v2 + 116);\n    if ( v3 )\n    {\n      kfree(*(_DWORD *)(v3 + 12));\n      v3 = *(_DWORD *)(v2 + 116);\n    }\n    result = kfree(v3);\n    *(_DWORD *)(v2 + 116) = 0;\n  }\n  return result;\n}\n",
    "pseudo_code_refined": "'int __fastcall kobject_put(int result)\\n{\\n  int v1; // r1\\n  int v2; // r4\\n  int v3; // r0\\n\\n  v1 = *(_DWORD *)(result + 116);\\n  if ( v1 )\\n  {\\n    v2 = result;\\n    sysfs_remove_group(result + 72, v1 + 4);\\n    v3 = *(_DWORD *)(v2 + 116);\\n    if ( v3 )\\n    {\\n      kfree(*(_DWORD *)(v3 + 12));\\n      v3 = *(_DWORD *)(v2 + 116);\\n    }\\n    result = kfree(v3);\\n    *(_DWORD *)(v2 + 116) = 0;\\n  }\\n  return result;\\n}\\n'"
  },
  {
    "function_name": "sg_init_one",
    "function_name_in_strip": "sub_C022AA80",
    "comment": "Initialize a single entry sg list",
    "function_body": [
      "PUSH <SPECIAL>",
      "MOV R5, R0",
      "MOV R4, R1",
      "MOV R1, <POSITIVE>",
      "MOV R6, R2",
      "BL <ICALL>",
      "LDR R3, [R5+<ZERO>]",
      "LDR R2, <MEM> =dword_C0522E3C",
      "BIC R3, R3, <POSITIVE>",
      "ORR R3, R3, <POSITIVE>",
      "STR R3, [R5+<ZERO>]",
      "LDR R3, [R2+<ZERO>]",
      "ADD R2, R4, <POSITIVE>",
      "MOV R2, <SPECIAL>",
      "ADD R3, R3, <SPECIAL>",
      "TST R3, <POSITIVE>",
      "B <NEAR>",
      "MOV R1, <SPECIAL>",
      "MOV R1, <SPECIAL>",
      "ORR R3, R3, <POSITIVE>",
      "STR R3, [R5+<ZERO>]",
      "STM R5, <SPECIAL>",
      "POP <SPECIAL>",
      "UND <POSITIVE>"
    ],
    "pseudo_code": "_DWORD *__fastcall sub_C022AA80(unsigned int *a1, int a2, unsigned int a3)\n{\n  _DWORD *result; // r0\n  unsigned int v7; // r3\n\n  result = sub_C02198C0(a1, 16);\n  *a1 = *a1 & 0xFFFFFFFC | 2;\n  v7 = dword_C0522E3C + 32 * ((unsigned int)(a2 + 0x40000000) >> 12);\n  if ( (v7 & 3) != 0 )\n    __und(0x12u);\n  *a1 = v7 | 2;\n  a1[1] = a2 & 0xFFF;\n  a1[2] = a3;\n  return result;\n}\n",
    "cfg": {
      "nodes": [
        "LDR_R2_<MEM>",
        "ADD_R3_R3_<SPECIAL>",
        "UND_<POSITIVE>",
        "POP_<SPECIAL>",
        "ORR_R3_R3_<POSITIVE>",
        "ADD_R2_R4_<POSITIVE>",
        "MOV_R1_<SPECIAL>",
        "LDR_R3_[R5*None+<ZERO>]",
        "STM_R5_<SPECIAL>",
        "MOV_R5_R0",
        "BL_<ICALL>",
        "TST_R3_<POSITIVE>",
        "MOV_R2_<SPECIAL>",
        "B_<NEAR>",
        "BIC_R3_R3_<POSITIVE>",
        "MOV_R1_<POSITIVE>",
        "MOV_R6_R2",
        "LDR_R3_[R2*None+<ZERO>]",
        "STR_R3_[R5*None+<ZERO>]",
        "PUSH_<SPECIAL>",
        "MOV_R4_R1"
      ],
      "edges": "[('LDR_R2_<MEM>', 'BIC_R3_R3_<POSITIVE>'), ('ADD_R3_R3_<SPECIAL>', 'TST_R3_<POSITIVE>'), ('ORR_R3_R3_<POSITIVE>', 'STR_R3_[R5*None+<ZERO>]'), ('ADD_R2_R4_<POSITIVE>', 'MOV_R2_<SPECIAL>'), ('MOV_R1_<SPECIAL>', 'MOV_R1_<SPECIAL>'), ('MOV_R1_<SPECIAL>', 'ORR_R3_R3_<POSITIVE>'), ('LDR_R3_[R5*None+<ZERO>]', 'LDR_R2_<MEM>'), ('STM_R5_<SPECIAL>', 'POP_<SPECIAL>'), ('MOV_R5_R0', 'MOV_R4_R1'), ('BL_<ICALL>', 'LDR_R3_[R5*None+<ZERO>]'), ('TST_R3_<POSITIVE>', 'B_<NEAR>'), ('MOV_R2_<SPECIAL>', 'ADD_R3_R3_<SPECIAL>'), ('B_<NEAR>', 'UND_<POSITIVE>'), ('B_<NEAR>', 'MOV_R1_<SPECIAL>'), ('BIC_R3_R3_<POSITIVE>', 'ORR_R3_R3_<POSITIVE>'), ('MOV_R1_<POSITIVE>', 'MOV_R6_R2'), ('MOV_R6_R2', 'BL_<ICALL>'), ('LDR_R3_[R2*None+<ZERO>]', 'ADD_R2_R4_<POSITIVE>'), ('STR_R3_[R5*None+<ZERO>]', 'LDR_R3_[R2*None+<ZERO>]'), ('STR_R3_[R5*None+<ZERO>]', 'STM_R5_<SPECIAL>'), ('PUSH_<SPECIAL>', 'MOV_R5_R0'), ('MOV_R4_R1', 'MOV_R1_<POSITIVE>')]",
      "edge_index": [
        [
          0,
          1,
          4,
          5,
          6,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          13,
          14,
          15,
          16,
          17,
          18,
          18,
          19,
          20
        ],
        [
          14,
          11,
          18,
          12,
          6,
          4,
          0,
          3,
          20,
          7,
          13,
          1,
          2,
          6,
          4,
          16,
          10,
          5,
          17,
          8,
          9,
          15
        ]
      ]
    },
    "pseudo_code_non_strip": "_DWORD *__fastcall sg_init_one(unsigned int *a1, int a2, unsigned int a3)\n{\n  _DWORD *result; // r0\n  unsigned int v7; // r3\n\n  result = _memzero(a1, 16);\n  *a1 = *a1 & 0xFFFFFFFC | 2;\n  v7 = shadow_nodes_key + 32 * ((unsigned int)(a2 + 0x40000000) >> 12);\n  if ( (v7 & 3) != 0 )\n    __und(0x12u);\n  *a1 = v7 | 2;\n  a1[1] = a2 & 0xFFF;\n  a1[2] = a3;\n  return result;\n}\n",
    "pseudo_code_refined": "'_DWORD *__fastcall memset(unsigned int *a1, int a2, unsigned int a3)\\n{\\n  _DWORD *result; // r0\\n  unsigned int v7; // r3\\n\\n  result = _kmalloc(a1, 16);\\n  *a1 = *a1 & 0xFFFFFFFC | 2;\\n  v7 = shadow_nodes_key + 32 * ((unsigned int)(a2 + 0x40000000) >> 12);\\n  if ( (v7 & 3) != 0 )\\n    __und(0x12u);\\n  *a1 = v7 | 2;\\n  a1[1] = a2 & 0xFFF;\\n  a1[2] = a3;\\n  return result;\\n}\\n'"
  },
  {
    "function_name": "task_sched_runtime",
    "function_name_in_strip": "sub_C005A634",
    "comment": "Return accounted runtime for the task",
    "function_body": [
      "PUSH <SPECIAL>",
      "MOV R4, R0",
      "ADD R11, SP, <POSITIVE>",
      "MRS R5, CPSR",
      "ORR R3, R5, <POSITIVE>",
      "MSR CPSR_c, R3",
      "LDR R3, [R4+<POSITIVE>]",
      "CMP R3, <POSITIVE>",
      "B <NEAR>",
      "LDR R6, <MEM> =dword_C0501FF0",
      "LDR R2, [R6+<POSITIVE>]",
      "CMP R2, R4",
      "CMP R3, <POSITIVE>",
      "B <NEAR>",
      "LDRD R0, R1, [R4+<POSITIVE>]",
      "MSR CPSR_c, R5",
      "POP <SPECIAL>",
      "LDR R0, [R6+<POSITIVE>]",
      "AND R0, R0, <POSITIVE>",
      "B <NEAR>",
      "LDR R3, [R4+<POSITIVE>]",
      "LDR R0, <MEM> =dword_C0501FF0",
      "LDR R3, [R3+<POSITIVE>]",
      "BLX <ICALL>",
      "B <NEAR>",
      "MSR CPSR_c, R5",
      "LDR R3, [R4+<POSITIVE>]",
      "CMP R3, <POSITIVE>",
      "B <NEAR>",
      "B <NEAR>",
      "BL <ICALL>",
      "ADD R12, R6, <POSITIVE>",
      "LDRD R2, R3, [R12+<NEGATIVE>]",
      "SUB R8, R0, R2",
      "SBC R9, R1, R3",
      "CMP R8, <ZERO>",
      "SBC R3, R9, <ZERO>",
      "B <NEAR>",
      "LDRD R6, R7, [R12+<ZERO>]",
      "ADD R2, R8, R6",
      "ADC R3, R9, R7",
      "STRD R0, R1, [R12+<NEGATIVE>]",
      "STRD R2, R3, [R12+<ZERO>]",
      "B <NEAR>"
    ],
    "pseudo_code": "__int64 __fastcall sub_C005A634(int a1)\n{\n  unsigned int CPSR; // r5\n  int v3; // r3\n  _BOOL1 v4; // zf\n  __int64 result; // r0\n  __int64 v6; // r0\n  __int64 v7; // r8\n\n  while ( 1 )\n  {\n    CPSR = __get_CPSR();\n    __set_CPSR(CPSR | 0x80);\n    v3 = *(_DWORD *)(a1 + 20);\n    if ( v3 != 2 )\n      break;\n    __set_CPSR(CPSR);\n    while ( *(_DWORD *)(a1 + 20) == 2 )\n      ;\n  }\n  v4 = off_C05023DC[0] == (int (*)(int, int, int, int, int, int, int))a1;\n  if ( off_C05023DC[0] == (int (*)(int, int, int, int, int, int, int))a1 )\n    v4 = v3 == 1;\n  if ( v4 )\n  {\n    if ( (dword_C05023F0 & 2) == 0 )\n    {\n      v6 = sub_C005EA78(0);\n      v7 = v6 - *(_QWORD *)&algn_C05023F4[4];\n      if ( (((unsigned __int64)(v6 - *(_QWORD *)&algn_C05023F4[4]) >> 32) & 0x80000000) == 0LL )\n      {\n        *(_QWORD *)&algn_C05023F4[4] = v6;\n        *(_QWORD *)dword_C0502400 += v7;\n      }\n    }\n    (*(void (__fastcall **)(int *))(*(_DWORD *)(a1 + 40) + 64))(&dword_C0501FF0);\n  }\n  result = *(_QWORD *)(a1 + 88);\n  __set_CPSR(CPSR);\n  return result;\n}\n",
    "cfg": {
      "nodes": [
        "MRS_R5_CPSR",
        "LDR_R6_<MEM>",
        "LDR_R2_[R6*None+<POSITIVE>]",
        "BLX_<ICALL>",
        "SUB_R8_R0_R2",
        "CMP_R2_R4",
        "ORR_R3_R5_<POSITIVE>",
        "POP_<SPECIAL>",
        "AND_R0_R0_<POSITIVE>",
        "MOV_R4_R0",
        "ADD_R11_SP_<POSITIVE>",
        "ADD_R12_R6_<POSITIVE>",
        "ADD_R2_R8_R6",
        "CMP_R8_<ZERO>",
        "LDR_R3_[R4*None+<POSITIVE>]",
        "BL_<ICALL>",
        "LDR_R0_[R6*None+<POSITIVE>]",
        "SBC_R9_R1_R3",
        "SBC_R3_R9_<ZERO>",
        "LDR_R3_[R3*None+<POSITIVE>]",
        "STRD_R0_R1_[R12*None+<NEGATIVE>]",
        "B_<NEAR>",
        "LDRD_R6_R7_[R12*None+<ZERO>]",
        "MSR_CPSR_c_R5",
        "MSR_CPSR_c_R3",
        "PUSH_<SPECIAL>",
        "LDR_R0_<MEM>",
        "CMP_R3_<POSITIVE>",
        "STRD_R2_R3_[R12*None+<ZERO>]",
        "ADC_R3_R9_R7",
        "LDRD_R2_R3_[R12*None+<NEGATIVE>]",
        "LDRD_R0_R1_[R4*None+<POSITIVE>]"
      ],
      "edges": "[('MRS_R5_CPSR', 'ORR_R3_R5_<POSITIVE>'), ('LDR_R6_<MEM>', 'LDR_R2_[R6*None+<POSITIVE>]'), ('LDR_R2_[R6*None+<POSITIVE>]', 'CMP_R2_R4'), ('BLX_<ICALL>', 'B_<NEAR>'), ('SUB_R8_R0_R2', 'SBC_R9_R1_R3'), ('CMP_R2_R4', 'CMP_R3_<POSITIVE>'), ('ORR_R3_R5_<POSITIVE>', 'MSR_CPSR_c_R3'), ('AND_R0_R0_<POSITIVE>', 'B_<NEAR>'), ('MOV_R4_R0', 'ADD_R11_SP_<POSITIVE>'), ('ADD_R11_SP_<POSITIVE>', 'MRS_R5_CPSR'), ('ADD_R12_R6_<POSITIVE>', 'LDRD_R2_R3_[R12*None+<NEGATIVE>]'), ('ADD_R2_R8_R6', 'ADC_R3_R9_R7'), ('CMP_R8_<ZERO>', 'SBC_R3_R9_<ZERO>'), ('LDR_R3_[R4*None+<POSITIVE>]', 'CMP_R3_<POSITIVE>'), ('LDR_R3_[R4*None+<POSITIVE>]', 'LDR_R0_<MEM>'), ('BL_<ICALL>', 'ADD_R12_R6_<POSITIVE>'), ('LDR_R0_[R6*None+<POSITIVE>]', 'AND_R0_R0_<POSITIVE>'), ('SBC_R9_R1_R3', 'CMP_R8_<ZERO>'), ('SBC_R3_R9_<ZERO>', 'B_<NEAR>'), ('LDR_R3_[R3*None+<POSITIVE>]', 'BLX_<ICALL>'), ('STRD_R0_R1_[R12*None+<NEGATIVE>]', 'STRD_R2_R3_[R12*None+<ZERO>]'), ('B_<NEAR>', 'MSR_CPSR_c_R5'), ('B_<NEAR>', 'B_<NEAR>'), ('B_<NEAR>', 'LDRD_R0_R1_[R4*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R6_<MEM>'), ('B_<NEAR>', 'LDR_R0_[R6*None+<POSITIVE>]'), ('B_<NEAR>', 'LDR_R3_[R4*None+<POSITIVE>]'), ('B_<NEAR>', 'BL_<ICALL>'), ('B_<NEAR>', 'LDRD_R6_R7_[R12*None+<ZERO>]'), ('B_<NEAR>', 'MRS_R5_CPSR'), ('LDRD_R6_R7_[R12*None+<ZERO>]', 'ADD_R2_R8_R6'), ('MSR_CPSR_c_R5', 'LDR_R3_[R4*None+<POSITIVE>]'), ('MSR_CPSR_c_R5', 'POP_<SPECIAL>'), ('MSR_CPSR_c_R3', 'LDR_R3_[R4*None+<POSITIVE>]'), ('PUSH_<SPECIAL>', 'MOV_R4_R0'), ('LDR_R0_<MEM>', 'LDR_R3_[R3*None+<POSITIVE>]'), ('CMP_R3_<POSITIVE>', 'B_<NEAR>'), ('STRD_R2_R3_[R12*None+<ZERO>]', 'B_<NEAR>'), ('ADC_R3_R9_R7', 'STRD_R0_R1_[R12*None+<NEGATIVE>]'), ('LDRD_R2_R3_[R12*None+<NEGATIVE>]', 'SUB_R8_R0_R2'), ('LDRD_R0_R1_[R4*None+<POSITIVE>]', 'MSR_CPSR_c_R5')]",
      "edge_index": [
        [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          21,
          22,
          23,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31
        ],
        [
          6,
          2,
          5,
          21,
          17,
          27,
          24,
          21,
          10,
          0,
          30,
          29,
          18,
          27,
          26,
          11,
          8,
          13,
          21,
          3,
          28,
          23,
          21,
          31,
          1,
          16,
          14,
          15,
          22,
          0,
          12,
          14,
          7,
          14,
          9,
          19,
          21,
          21,
          20,
          4,
          23
        ]
      ]
    },
    "pseudo_code_non_strip": "__int64 __fastcall task_sched_runtime(int a1, int a2)\n{\n  unsigned int CPSR; // r5\n  int v4; // r3\n  bool v5; // zf\n  __int64 result; // r0\n  __int64 v7; // r0\n  __int64 v8; // r8\n\n  while ( 1 )\n  {\n    CPSR = __get_CPSR();\n    __set_CPSR(CPSR | 0x80);\n    v4 = *(_DWORD *)(a1 + 20);\n    if ( v4 != 2 )\n      break;\n    __set_CPSR(CPSR);\n    while ( *(_DWORD *)(a1 + 20) == 2 )\n      ;\n  }\n  v5 = off_C05023DC[0] == (int (*)())a1;\n  if ( off_C05023DC[0] == (int (*)())a1 )\n    v5 = v4 == 1;\n  if ( v5 )\n  {\n    if ( (dword_C05023F0 & 2) == 0 )\n    {\n      v7 = sched_clock_cpu(0, a2);\n      v8 = v7 - *(_QWORD *)&algn_C05023F4[4];\n      if ( (((unsigned __int64)(v7 - *(_QWORD *)&algn_C05023F4[4]) >> 32) & 0x80000000) == 0LL )\n      {\n        *(_QWORD *)&algn_C05023F4[4] = v7;\n        *(_QWORD *)dword_C0502400 += v8;\n      }\n    }\n    (*(void (__fastcall **)(int *))(*(_DWORD *)(a1 + 40) + 64))(&runqueues);\n  }\n  result = *(_QWORD *)(a1 + 88);\n  __set_CPSR(CPSR);\n  return result;\n}\n",
    "pseudo_code_refined": "'__int64 __fastcall kthread_stop(int a1)\\n{\\n  unsigned int CPSR; // r5\\n  int v3; // r3\\n  bool v4; // zf\\n  __int64 result; // r0\\n  __int64 v6; // r0\\n  __int64 v7; // r8\\n\\n  while ( 1 )\\n  {\\n    CPSR = __get_CPSR();\\n    __set_CPSR(CPSR | 0x80);\\n    v3 = *(_DWORD *)(a1 + 20);\\n    if ( v3 != 2 )\\n      break;\\n    __set_CPSR(CPSR);\\n    while ( *(_DWORD *)(a1 + 20) == 2 )\\n      ;\\n  }\\n  v4 = ksoftirqd[0] == (int (*)())a1;\\n  if ( ksoftirqd[0] == (int (*)())a1 )\\n    v4 = v3 == 1;\\n  if ( v4 )\\n  {\\n    if ( (system_state & 2) == 0 )\\n    {\\n      v6 = kthread_data(0);\\n      v7 = v6 - *(_QWORD *)&algn_C05023F4[4];\\n      if ( (((unsigned __int64)(v6 - *(_QWORD *)&algn_C05023F4[4]) >> 32) & 0x80000000) != 0x80000000 )\\n      {\\n        result = kthread_stop(0);\\n        v7 = v6 - *(_QWORD *)&algn_C05023F4"
  },
  {
    "function_name": "ulc_grapheme_breaks",
    "function_name_in_strip": "ulc_grapheme_breaks",
    "comment": "Grapheme boundaries in a string in an arbitrary encoding",
    "function_body": [
      "PUSH <SPECIAL>",
      "SUB R6, R1, <ZERO>",
      "SUB SP, SP, <POSITIVE>",
      "B <NEAR>",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>",
      "MOV R5, R2",
      "MOV R4, R0",
      "BL <ECALL> j_locale_charset",
      "LDR R3, [R0+<ZERO>]",
      "MOV R9, R0",
      "BIC R3, R3, <POSITIVE>",
      "CMP R3, <POSITIVE>",
      "B <NEAR>",
      "MOV R7, <SPECIAL>",
      "MOV R0, R7",
      "BL <ECALL> malloc",
      "SUB R8, R0, <ZERO>",
      "B <NEAR>",
      "MOV R3, <ZERO>",
      "STR R3, [SP+<POSITIVE>]",
      "ADD R3, SP, <POSITIVE>",
      "MOV R0, R9",
      "STR R3, [SP+<POSITIVE>]",
      "STR R8, [SP+<ZERO>]",
      "MOV R3, R6",
      "MOV R2, R4",
      "MOV R1, <POSITIVE>",
      "BL <ECALL> j_u8_conv_from_encoding",
      "SUB R9, R0, <ZERO>",
      "B <NEAR>",
      "LDR R11, [SP+<POSITIVE>]",
      "CMP R11, <ZERO>",
      "MOV R10, R11",
      "B <NEAR>",
      "MOV R1, R11",
      "MOV R2, R10",
      "MOV R0, R9",
      "BL <ECALL> j_u8_grapheme_breaks",
      "MOV R2, R6",
      "MOV R1, <ZERO>",
      "MOV R0, R5",
      "BL <ECALL> memset",
      "MOV R2, R5",
      "SUB R7, R7, <POSITIVE>",
      "ADD R7, R8, R7",
      "SUB R3, R8, <POSITIVE>",
      "LDR R1, [R3+<POSITIVE>]",
      "ADD R2, R2, <POSITIVE>",
      "CMN R1, <POSITIVE>",
      "LDR R1, [R10,R1]",
      "STR R1, [R2+<NEGATIVE>]",
      "CMP R7, R3",
      "B <NEAR>",
      "MOV R0, R10",
      "BL <ECALL> free",
      "MOV R0, R9",
      "BL <ECALL> free",
      "MOV R0, R8",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>",
      "B <NEAR>",
      "LDR R3, [R0+<POSITIVE>]",
      "BIC R3, R3, <POSITIVE>",
      "CMP R3, <POSITIVE>",
      "B <NEAR>",
      "LDR R3, [R0+<POSITIVE>]",
      "BIC R3, R3, <POSITIVE>",
      "CMP R3, <POSITIVE>",
      "B <NEAR>",
      "LDR R3, [R0+<POSITIVE>]",
      "CMP R3, <POSITIVE>",
      "B <NEAR>",
      "LDR R3, [R0+<POSITIVE>]",
      "CMP R3, <POSITIVE>",
      "B <NEAR>",
      "LDR R3, [R0+<POSITIVE>]",
      "CMP R3, <ZERO>",
      "B <NEAR>",
      "MOV R2, R5",
      "MOV R1, R6",
      "MOV R0, R4",
      "BL <ECALL> j_u8_grapheme_breaks",
      "ADD SP, SP, <POSITIVE>",
      "POP <SPECIAL>",
      "MOV R0, R11",
      "BL <ECALL> malloc",
      "SUB R10, R0, <ZERO>",
      "B <NEAR>",
      "MOV R0, R9",
      "BL <ECALL> free",
      "MOV R0, R8",
      "BL <ECALL> free",
      "MOV R3, <POSITIVE>",
      "CMP R6, R3",
      "STR R3, [R5+<ZERO>]",
      "B <NEAR>",
      "SUB R1, R4, <POSITIVE>",
      "MOV R0, R4",
      "MOV R2, R5",
      "ADD R6, R1, R6",
      "B <NEAR>",
      "CMP R6, R0",
      "STR R3, [R2+<POSITIVE>]",
      "B <NEAR>",
      "LDR R3, [R0+<POSITIVE>]",
      "SUB R12, R3, <POSITIVE>",
      "CMP R12, <POSITIVE>",
      "SUB LR, R3, <POSITIVE>",
      "B <NEAR>",
      "CMP LR, <POSITIVE>",
      "MOV R3, <ZERO>",
      "B <NEAR>",
      "CMP R3, <POSITIVE>",
      "MOV R3, <POSITIVE>",
      "B <NEAR>",
      "LDR R3, [R0+<NEGATIVE>]",
      "SUB R3, R3, <POSITIVE>",
      "MOV R3, <POSITIVE>",
      "B <NEAR>"
    ],
    "pseudo_code": "void __fastcall ulc_grapheme_breaks(int a1, size_t a2, _BYTE *a3)\n{\n  const char *v6; // r0\n  int v7; // r9\n  char *v8; // r8\n  void *v9; // r9\n  size_t v10; // r11\n  void *v11; // r10\n  _BYTE *v12; // r2\n  char *v13; // r3\n  int v14; // r1\n  int v15; // t1\n  void *v16; // r0\n  int v17; // r0\n  _BYTE *v18; // r2\n  size_t v19; // r6\n  int v20; // r3\n  int v21; // t1\n  unsigned int v22; // lr\n  bool v23; // r3\n  size_t size; // [sp+14h] [bp-2Ch] BYREF\n\n  if ( !a2 )\n    return;\n  v6 = j_locale_charset();\n  v7 = (int)v6;\n  if ( (*v6 & 0xDF) == 85 && (v6[1] & 0xDF) == 84 && (v6[2] & 0xDF) == 70 && v6[3] == 45 && v6[4] == 56 && !v6[5] )\n  {\n    j_u8_grapheme_breaks(a1, a2, a3);\n    return;\n  }\n  v8 = (char *)malloc(4 * a2);\n  if ( v8 )\n  {\n    v9 = (void *)j_u8_conv_from_encoding(v7, 1, a1, a2, (int)v8, 0, (int)&size);\n    if ( v9 )\n    {\n      v10 = size;\n      if ( !size )\n      {\n        v11 = 0;\n        goto LABEL_9;\n      }\n      v16 = malloc(size);\n      v11 = v16;\n      if ( v16 )\n      {\nLABEL_9:\n        j_u8_grapheme_breaks((int)v9, v10, v11);\n        memset(a3, 0, a2);\n        v12 = a3;\n        v13 = v8 - 4;\n        do\n        {\n          v15 = *((_DWORD *)v13 + 1);\n          v13 += 4;\n          v14 = v15;\n          ++v12;\n          if ( v15 != -1 )\n            *(v12 - 1) = *((_BYTE *)v11 + v14);\n        }\n        while ( &v8[4 * a2 - 4] != v13 );\n        free(v11);\n        free(v9);\n        free(v8);\n        return;\n      }\n      free(v9);\n    }\n    free(v8);\n  }\n  *a3 = 1;\n  if ( a2 > 1 )\n  {\n    v17 = a1;\n    v18 = a3;\n    v19 = a1 - 1 + a2;\n    do\n    {\n      v21 = *(unsigned __int8 *)++v17;\n      v20 = v21;\n      v22 = v21 - 9;\n      v23 = ((unsigned int)(v21 - 32) <= 0x5E || v22 <= 4) && (v20 != 10 || *(_BYTE *)(v17 - 1) != 13);\n      *++v18 = v23;\n    }\n    while ( v19 != v17 );\n  }\n}\n",
    "cfg": {
      "nodes": [
        "MOV_R0_R10",
        "LDR_R3_[R0*None+<POSITIVE>]",
        "MOV_R0_R9",
        "SUB_R6_R1_<ZERO>",
        "MOV_R0_R5",
        "B_<NEAR>",
        "LDR_R11_[SP*None+<POSITIVE>]",
        "MOV_R0_R11",
        "MOV_R2_R5",
        "POP_<SPECIAL>",
        "SUB_SP_SP_<POSITIVE>",
        "MOV_R1_<POSITIVE>",
        "CMP_R11_<ZERO>",
        "SUB_R3_R3_<POSITIVE>",
        "MOV_R2_R10",
        "CMP_LR_<POSITIVE>",
        "SUB_LR_R3_<POSITIVE>",
        "LDR_R1_[R10]",
        "SUB_R8_R0_<ZERO>",
        "LDR_R3_[R0*None+<NEGATIVE>]",
        "MOV_R5_R2",
        "STR_R8_[SP*None+<ZERO>]",
        "CMP_R12_<POSITIVE>",
        "CMN_R1_<POSITIVE>",
        "STR_R3_[R5*None+<ZERO>]",
        "MOV_R0_R8",
        "PUSH_<SPECIAL>",
        "MOV_R10_R11",
        "LDR_R1_[R3*None+<POSITIVE>]",
        "ADD_R3_SP_<POSITIVE>",
        "MOV_R3_<ZERO>",
        "MOV_R4_R0",
        "BIC_R3_R3_<POSITIVE>",
        "STR_R1_[R2*None+<NEGATIVE>]",
        "SUB_R1_R4_<POSITIVE>",
        "CMP_R6_R0",
        "BL_<ECALL>",
        "MOV_R1_R6",
        "ADD_R2_R2_<POSITIVE>",
        "STR_R3_[R2*None+<POSITIVE>]",
        "ADD_SP_SP_<POSITIVE>",
        "MOV_R2_R6",
        "STR_R3_[SP*None+<POSITIVE>]",
        "CMP_R3_<ZERO>",
        "MOV_R7_<SPECIAL>",
        "ADD_R7_R8_R7",
        "MOV_R0_R4",
        "MOV_R3_R6",
        "SUB_R7_R7_<POSITIVE>",
        "MOV_R9_R0",
        "CMP_R3_<POSITIVE>",
        "MOV_R1_<ZERO>",
        "SUB_R12_R3_<POSITIVE>",
        "MOV_R1_R11",
        "SUB_R10_R0_<ZERO>",
        "CMP_R7_R3",
        "MOV_R0_R7",
        "MOV_R2_R4",
        "SUB_R3_R8_<POSITIVE>",
        "SUB_R9_R0_<ZERO>",
        "LDR_R3_[R0*None+<ZERO>]",
        "CMP_R6_R3",
        "ADD_R6_R1_R6",
        "MOV_R3_<POSITIVE>",
        "ADRL_R12_<POSITIVE>"
      ],
      "edges": "[('MOV_R0_R10', 'BL_<ECALL>'), ('LDR_R3_[R0*None+<POSITIVE>]', 'BIC_R3_R3_<POSITIVE>'), ('LDR_R3_[R0*None+<POSITIVE>]', 'CMP_R3_<POSITIVE>'), ('LDR_R3_[R0*None+<POSITIVE>]', 'CMP_R3_<ZERO>'), ('LDR_R3_[R0*None+<POSITIVE>]', 'SUB_R12_R3_<POSITIVE>'), ('MOV_R0_R9', 'STR_R3_[SP*None+<POSITIVE>]'), ('MOV_R0_R9', 'BL_<ECALL>'), ('SUB_R6_R1_<ZERO>', 'SUB_SP_SP_<POSITIVE>'), ('MOV_R0_R5', 'BL_<ECALL>'), ('B_<NEAR>', 'MOV_R0_R10'), ('B_<NEAR>', 'LDR_R3_[R0*None+<POSITIVE>]'), ('B_<NEAR>', 'SUB_R1_R4_<POSITIVE>'), ('B_<NEAR>', 'LDR_R3_[R0*None+<NEGATIVE>]'), ('B_<NEAR>', 'MOV_R2_R5'), ('B_<NEAR>', 'LDR_R11_[SP*None+<POSITIVE>]'), ('B_<NEAR>', 'MOV_R0_R11'), ('B_<NEAR>', 'MOV_R3_<ZERO>'), ('B_<NEAR>', 'CMP_R6_R0'), ('B_<NEAR>', 'ADRL_R12_<POSITIVE>'), ('B_<NEAR>', 'MOV_R7_<SPECIAL>'), ('B_<NEAR>', 'MOV_R0_R8'), ('B_<NEAR>', 'LDR_R1_[R3*None+<POSITIVE>]'), ('B_<NEAR>', 'MOV_R3_<POSITIVE>'), ('B_<NEAR>', 'MOV_R0_R9'), ('B_<NEAR>', 'CMP_R3_<POSITIVE>'), ('B_<NEAR>', 'MOV_R1_R11'), ('B_<NEAR>', 'CMP_LR_<POSITIVE>'), ('B_<NEAR>', 'ADD_SP_SP_<POSITIVE>'), ('B_<NEAR>', 'MOV_R5_R2'), ('LDR_R11_[SP*None+<POSITIVE>]', 'CMP_R11_<ZERO>'), ('MOV_R0_R11', 'BL_<ECALL>'), ('MOV_R2_R5', 'ADD_R6_R1_R6'), ('MOV_R2_R5', 'MOV_R1_R6'), ('MOV_R2_R5', 'SUB_R7_R7_<POSITIVE>'), ('POP_<SPECIAL>', 'B_<NEAR>'), ('SUB_SP_SP_<POSITIVE>', 'B_<NEAR>'), ('MOV_R1_<POSITIVE>', 'BL_<ECALL>'), ('CMP_R11_<ZERO>', 'MOV_R10_R11'), ('SUB_R3_R3_<POSITIVE>', 'MOV_R3_<POSITIVE>'), ('MOV_R2_R10', 'MOV_R0_R9'), ('CMP_LR_<POSITIVE>', 'MOV_R3_<ZERO>'), ('SUB_LR_R3_<POSITIVE>', 'B_<NEAR>'), ('LDR_R1_[R10]', 'STR_R1_[R2*None+<NEGATIVE>]'), ('SUB_R8_R0_<ZERO>', 'B_<NEAR>'), ('LDR_R3_[R0*None+<NEGATIVE>]', 'SUB_R3_R3_<POSITIVE>'), ('MOV_R5_R2', 'MOV_R4_R0'), ('STR_R8_[SP*None+<ZERO>]', 'MOV_R3_R6'), ('CMP_R12_<POSITIVE>', 'SUB_LR_R3_<POSITIVE>'), ('CMN_R1_<POSITIVE>', 'LDR_R1_[R10]'), ('STR_R3_[R5*None+<ZERO>]', 'B_<NEAR>'), ('MOV_R0_R8', 'ADD_SP_SP_<POSITIVE>'), ('MOV_R0_R8', 'BL_<ECALL>'), ('PUSH_<SPECIAL>', 'SUB_R6_R1_<ZERO>'), ('MOV_R10_R11', 'B_<NEAR>'), ('LDR_R1_[R3*None+<POSITIVE>]', 'ADD_R2_R2_<POSITIVE>'), ('ADD_R3_SP_<POSITIVE>', 'MOV_R0_R9'), ('MOV_R3_<ZERO>', 'B_<NEAR>'), ('MOV_R3_<ZERO>', 'STR_R3_[SP*None+<POSITIVE>]'), ('MOV_R4_R0', 'BL_<ECALL>'), ('BIC_R3_R3_<POSITIVE>', 'CMP_R3_<POSITIVE>'), ('STR_R1_[R2*None+<NEGATIVE>]', 'CMP_R7_R3'), ('SUB_R1_R4_<POSITIVE>', 'MOV_R0_R4'), ('CMP_R6_R0', 'STR_R3_[R2*None+<POSITIVE>]'), ('BL_<ECALL>', 'LDR_R3_[R0*None+<ZERO>]'), ('BL_<ECALL>', 'SUB_R9_R0_<ZERO>'), ('BL_<ECALL>', 'SUB_R8_R0_<ZERO>'), ('BL_<ECALL>', 'SUB_R10_R0_<ZERO>'), ('BL_<ECALL>', 'MOV_R2_R5'), ('BL_<ECALL>', 'MOV_R0_R8'), ('BL_<ECALL>', 'ADD_SP_SP_<POSITIVE>'), ('BL_<ECALL>', 'MOV_R2_R6'), ('BL_<ECALL>', 'MOV_R3_<POSITIVE>'), ('BL_<ECALL>', 'MOV_R0_R9'), ('MOV_R1_R6', 'MOV_R0_R4'), ('ADD_R2_R2_<POSITIVE>', 'CMN_R1_<POSITIVE>'), ('STR_R3_[R2*None+<POSITIVE>]', 'B_<NEAR>'), ('ADD_SP_SP_<POSITIVE>', 'POP_<SPECIAL>'), ('MOV_R2_R6', 'MOV_R1_<ZERO>'), ('STR_R3_[SP*None+<POSITIVE>]', 'ADD_R3_SP_<POSITIVE>'), ('STR_R3_[SP*None+<POSITIVE>]', 'STR_R8_[SP*None+<ZERO>]'), ('CMP_R3_<ZERO>', 'B_<NEAR>'), ('MOV_R7_<SPECIAL>', 'MOV_R0_R7'), ('ADD_R7_R8_R7', 'SUB_R3_R8_<POSITIVE>'), ('MOV_R0_R4', 'BL_<ECALL>'), ('MOV_R0_R4', 'MOV_R2_R5'), ('MOV_R3_R6', 'MOV_R2_R4'), ('SUB_R7_R7_<POSITIVE>', 'ADD_R7_R8_R7'), ('MOV_R9_R0', 'BIC_R3_R3_<POSITIVE>'), ('CMP_R3_<POSITIVE>', 'B_<NEAR>'), ('CMP_R3_<POSITIVE>', 'MOV_R3_<POSITIVE>'), ('MOV_R1_<ZERO>', 'MOV_R0_R5'), ('SUB_R12_R3_<POSITIVE>', 'CMP_R12_<POSITIVE>'), ('MOV_R1_R11', 'MOV_R2_R10'), ('SUB_R10_R0_<ZERO>', 'B_<NEAR>'), ('CMP_R7_R3', 'B_<NEAR>'), ('MOV_R0_R7', 'BL_<ECALL>'), ('MOV_R2_R4', 'MOV_R1_<POSITIVE>'), ('SUB_R3_R8_<POSITIVE>', 'LDR_R1_[R3*None+<POSITIVE>]'), ('SUB_R9_R0_<ZERO>', 'B_<NEAR>'), ('LDR_R3_[R0*None+<ZERO>]', 'MOV_R9_R0'), ('CMP_R6_R3', 'STR_R3_[R5*None+<ZERO>]'), ('ADD_R6_R1_R6', 'B_<NEAR>'), ('MOV_R3_<POSITIVE>', 'CMP_R6_R3'), ('MOV_R3_<POSITIVE>', 'B_<NEAR>')]",
      "edge_index": [
        [
          0,
          1,
          1,
          1,
          1,
          2,
          2,
          3,
          4,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          6,
          7,
          8,
          8,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          25,
          26,
          27,
          28,
          29,
          30,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          36,
          36,
          36,
          36,
          36,
          36,
          36,
          36,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          42,
          43,
          44,
          45,
          46,
          46,
          47,
          48,
          49,
          50,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          63
        ],
        [
          36,
          32,
          50,
          43,
          52,
          42,
          36,
          10,
          36,
          0,
          1,
          34,
          19,
          8,
          6,
          7,
          30,
          35,
          64,
          44,
          25,
          28,
          63,
          2,
          50,
          53,
          15,
          40,
          20,
          12,
          36,
          62,
          37,
          48,
          5,
          5,
          36,
          27,
          63,
          2,
          30,
          5,
          33,
          5,
          13,
          31,
          47,
          16,
          17,
          5,
          40,
          36,
          3,
          5,
          38,
          2,
          5,
          42,
          36,
          50,
          55,
          46,
          39,
          60,
          59,
          18,
          54,
          8,
          25,
          40,
          41,
          63,
          2,
          46,
          23,
          5,
          9,
          51,
          29,
          21,
          5,
          56,
          58,
          36,
          8,
          57,
          45,
          32,
          5,
          63,
          4,
          22,
          14,
          5,
          5,
          36,
          11,
          28,
          5,
          49,
          24,
          5,
          61,
          5
        ]
      ]
    },
    "pseudo_code_non_strip": "void __fastcall ulc_grapheme_breaks(const unsigned __int8 *s, size_t a2, unsigned __int8 *p)\n{\n  size_t *v3; // r7\n  unsigned __int8 *v4; // r11\n  const unsigned __int8 *v8; // r0\n  unsigned __int8 *v9; // r9\n  unsigned __int8 *resultbuf; // r8\n  unistring_uint8_t *v11; // r9\n  _BYTE *v12; // r10\n  unsigned __int8 *v13; // r2\n  unsigned __int8 *v14; // r3\n  int v15; // r1\n  int v16; // t1\n  _BYTE *v17; // r0\n  const unsigned __int8 *v18; // r0\n  unsigned __int8 *v19; // r2\n  const unsigned __int8 *v20; // r6\n  int v21; // r3\n  int v22; // t1\n  unsigned int v23; // lr\n  bool v24; // r3\n  unsigned __int8 *m; // [sp+14h] [bp-2Ch]\n\n  if ( !a2 )\n    return;\n  v8 = j_locale_charset();\n  v9 = (unsigned __int8 *)v8;\n  if ( (*v8 & 0xDF) == 85 && (v8[1] & 0xDF) == 84 && (v8[2] & 0xDF) == 70 && v8[3] == 45 && v8[4] == 56 && !v8[5] )\n  {\n    j_u8_grapheme_breaks(s, a2, v4);\n    return;\n  }\n  resultbuf = (unsigned __int8 *)malloc(4 * a2);\n  if ( resultbuf )\n  {\n    v11 = j_u8_conv_from_encoding(v9, iconveh_question_mark, resultbuf, a2, v3, resultbuf, (size_t *)v9);\n    if ( v11 )\n    {\n      if ( !m )\n      {\n        v12 = 0;\n        goto LABEL_9;\n      }\n      v17 = malloc((size_t)m);\n      v12 = v17;\n      if ( v17 )\n      {\nLABEL_9:\n        j_u8_grapheme_breaks(s, (size_t)m, m);\n        memset(p, 0, a2);\n        v13 = p;\n        v14 = resultbuf - 4;\n        do\n        {\n          v16 = *((_DWORD *)v14 + 1);\n          v14 += 4;\n          v15 = v16;\n          ++v13;\n          if ( v16 != -1 )\n            *(v13 - 1) = v12[v15];\n        }\n        while ( &resultbuf[4 * a2 - 4] != v14 );\n        free(v12);\n        free(v11);\n        free(resultbuf);\n        return;\n      }\n      free(v11);\n    }\n    free(resultbuf);\n  }\n  *p = 1;\n  if ( a2 > 1 )\n  {\n    v18 = s;\n    v19 = p;\n    v20 = &s[a2 - 1];\n    do\n    {\n      v22 = *++v18;\n      v21 = v22;\n      v23 = v22 - 9;\n      v24 = ((unsigned int)(v22 - 32) <= 0x5E || v23 <= 4) && (v21 != 10 || *(v18 - 1) != 13);\n      *++v19 = v24;\n    }\n    while ( v20 != v18 );\n  }\n}\n",
    "pseudo_code_refined": "'void __fastcall ulc_grapheme_breaks(int a1, size_t a2, _BYTE *a3)\\n{\\n  const char *v6; // r0\\n  int v7; // r9\\n  char *v8; // r8\\n  void *v9; // r9\\n  size_t v10; // r11\\n  void *v11; // r10\\n  _BYTE *v12; // r2\\n  char *v13; // r3\\n  int v14; // r1\\n  int v15; // t1\\n  void *v16; // r0\\n  int v17; // r0\\n  _BYTE *v18; // r2\\n  size_t v19; // r6\\n  int v20; // r3\\n  int v21; // t1\\n  unsigned int v22; // lr\\n  _BOOL4 v23; // r3\\n  size_t size; // [sp+14h] [bp-2Ch] BYREF\\n\\n  if ( !a2 )\\n    return;\\n  v6 = j_locale_charset();\\n  v7 = (int)v6;\\n  if ( (*v6 & 0xDF) == 85 && (v6[1] & 0xDF) == 84 && (v6[2] & 0xDF) == 70 && v6[3] == 45 && v6[4] == 56 && !v6[5] )\\n  {\\n    j_u8_grapheme_breaks(a1, a2, a3);\\n    return;\\n  }\\n  v8 = (char *)"
  }
]